{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":""},{"location":"#foldable-grasshopper-inspired-walking-robot","title":"Foldable Grasshopper-Inspired Walking Robot","text":""},{"location":"#team","title":"Team","text":"<ul> <li>Vamshi Narayana Babu \u2013 vamshin24@asu.edu</li> <li>Sameerjeet Singh Chhabra \u2013 schhab18@asu.edu</li> <li>Shawn Dimang \u2013 shawn.dimang@asu.edu</li> </ul>"},{"location":"#introduction","title":"Introduction","text":"<p>This project explores the design and simulation of a bio-inspired walking robot based on the grasshopper's morphology. Originally conceived as a jumping mechanism, the design was pivoted to a walking gait to ensure stability and control using a four-bar linkage leg design.</p> <p>The robot is constructed using a foldable cardboard technique with a five-layer lamination process, allowing for rapid prototyping and lightweight structure. We utilized MuJoCo for physics-based modeling and optimization, focusing on maximizing the distance traveled in 10 seconds as our primary performance metric.</p> <p>Project Pivot: Our original goal was to study and optimize jumping performance of a grasshopper-inspired mechanism. During prototyping we observed more reliable and repeatable walking behavior, so we pivoted the project to focus on walking locomotion and use distance covered in 10 seconds as the primary performance metric.</p>"},{"location":"#research-question","title":"Research Question","text":"<p>How can a grasshopper-inspired four-bar linkage mechanism be optimized for stable walking using a foldable cardboard structure, and how well does the simulated performance in MuJoCo correlate with the physical prototype?</p>"},{"location":"#background-biomechanics","title":"Background &amp; Biomechanics","text":"<p>Grasshoppers utilize a specialized leg structure that allows for powerful extension. We analyzed the kinematic chain of the grasshopper leg to adapt it into a four-bar linkage suitable for a walking gait driven by continuous servo rotation rather than explosive energy release. </p>"},{"location":"#kinematics-and-dynamics","title":"Kinematics and Dynamics","text":"<p>We modeled the system\u2019s kinematics and dynamics using Python and Jacobian.</p> <ul> <li>Kinematics and Dynamics</li> </ul>"},{"location":"#specifications-table","title":"Specifications Table","text":"Parameter Symbol Value (example) Units Notes Total robot mass \\(m\\) ~0.045 kg Measured including batteries and two servos Body length \\(L_b\\) ~0.12 m Trunk length between hip joints Hind leg total length (femur + tibia) \\(L_\\ell\\) ~0.07 m From hip joint to foot tip Number of actuated DOFs \u2013 2 \u2013 One servo per hind leg (hip joint) Servo model \u2013 SG90-class \u2013 4.8\u20136 V micro servo, ~1.8 kg\u00b7cm stall torque Nominal servo angular range \\(\\Delta\\theta\\) 60\u201390 deg Commanded sweep for walking Nominal gait frequency \\(f\\) 1\u20133 Hz Full back-and-forth motion of legs Effective joint stiffness (laminate) \\(k_\\theta\\) 0.1\u20130.3 N\u00b7m/rad Identified from bending tests Coefficient of static friction (foot\u2013ground) \\(\\mu_s\\) 0.5\u20130.7 \u2013 Cardboard foot on lab surface Primary performance metric \u2013 COM displacement m Net forward distance along x-axis"},{"location":"#design-mechanism-manufacturing","title":"Design Mechanism &amp; Manufacturing","text":"<ul> <li>Leg Design: A four-bar linkage system mimics the femur-tibia articulation of a grasshopper in libreCAD. Added cuts, joints and hinges to the design.</li> <li>Construction: Built using a 5-layer lamination process (cardboard, adhesive, and flexible layers) to create robust yet foldable joints.</li> <li>Actuation: Driven by standard SG90 servos controlling the input crank of the linkage.</li> <li>CAD Design</li> </ul> <ul> <li>LibreCAD Design</li> </ul> <ul> <li>Body/Trunk 5 Layer Design</li> </ul> <ul> <li>Hind Legs 5 Layer Design</li> </ul> <ul> <li>5 Layered Manufacturing Workflow for hind legs</li> </ul> <ul> <li>5 Layered Manufacturing Workflow for main body(Trunk)</li> </ul>"},{"location":"#parameter-sweep-optimization","title":"Parameter Sweep &amp; Optimization","text":"<p>We performed parameter sweeps on link material stiffness, damping, servo frequency and friction to identify the optimal configuration for speed and stability.</p> <p>Motor Parameter Identification:</p> <ul> <li> <p>We commanded sinusoidal or square-wave position trajectories at certain frequencies and recorded the actual angle using a printed protractor and video tracking.  </p> </li> <li> <p>The resulting angle\u2013time data allowed us to estimate the effective maximum angular speed, the steady-state lag between command and motion, and qualitative saturation behavior at higher frequencies.</p> </li> <li> <p>Motor Behavior: Parameter Identification</p> </li> </ul> <p>Material Parameter Identification: We characterized the effective bending stiffness and damping of the laminated cardboard:</p> <ul> <li> <p>Setup: A cantilever strip matching the leg link cross-section was clamped at one end while small weights were hung at the free end. Deflection under static load gave a force\u2013displacement curve.</p> </li> <li> <p>Dynamic test: The same strip was displaced and released; we recorded its free vibration using a smartphone at high frame rate. Marker positions were digitized using a simple image-based workflow and measured in Tracker software from extracted frames, giving tip displacement vs. time.</p> </li> <li> <p>Stiffness and dampening of the material: Parameter Identification</p> </li> </ul> <p>Friction Identification:</p> <ul> <li> <p>Inclined-plane method: A small block with the laminated foot pad on its underside was placed on an adjustable ramp covered with the same surface as our test field. The critical angle \\(\\alpha_c\\) at which the block started sliding gave \\(\\mu_s \\approx \\tan \\alpha_c\\).</p> </li> <li> <p>Drag test: We pulled the robot slowly using a force sensor to estimate kinetic friction during steady sliding.</p> </li> <li> <p>Friction and Spring: Parameter Identification</p> </li> </ul>"},{"location":"#modeling-simulation-mujoco","title":"Modeling &amp; Simulation (MuJoCo)","text":"<p>We developed a full physics simulation in MuJoCo to test the stability and kinematics of the walking gait before physical assembly.</p> <p></p> <ul> <li>Model &amp; Simulation Notebook </li> <li>MuJoCo Model Walking Demonstration:</li> </ul> <ul> <li>Real-world Prototype: The trunk was assembled first, with servos mounted aft and their horns protruding through the side walls. Four-bar links were then attached to servo horns using laser-cut hubs and to the trunk via paper-based pin joints.</li> </ul> <p></p>"},{"location":"#design-optimization","title":"Design Optimization","text":"<p>We optimized our design on Angle parameter. The angles of the femur and tibia from one link to another was optimized with trial and error method. </p>"},{"location":"#results","title":"Results","text":"<p>The optimized design achieved a stable walking gait in simulation with a total distance of 0.11 meters in 10 seconds. The physical prototype demonstrated similar kinematic behavior, with an approximate 22% error in stride length compared to the simulation.</p> <p></p> <p>We were not able to reliably log position data from the physical robot because it traversed in both the x and y directions, making a clean 1D trajectory hard to extract. Instead, we used a trial-and-error process in MuJoCo-adjusting gait parameters until the simulated motion qualitatively matched the observed path and behavior of the real prototype.</p>"},{"location":"#physical-prototype-performance","title":"Physical prototype performance","text":"<p>We implemented the optimized parameters on the physical robot by selecting the closest achievable servo frequency and amplitude and running repeated 10-second walking trials on a flat surface. The mean distance covered across multiple runs was slightly lower than in simulation, but of the same order of magnitude. The percentage error between simulation and experiment was on the order of 5\u201322%, depending on the trial set.</p> <p>Qualitatively:</p> <ul> <li>The prototype exhibited a clear stick\u2013slip gait: during the backward stroke, feet gripped and pushed the robot forward; during the forward stroke, partial slipping and some lifting reduced backward motion.</li> <li> <p>Minor asymmetries in fabrication and servo mounting produced a slight curvature in the walking path, which was not captured in the symmetric simulation model.</p> </li> <li> <p>Walking Demonstration:</p> </li> </ul>"},{"location":"#files-downloads","title":"Files &amp; Downloads","text":"<ul> <li>Final Report (PDF)</li> <li>CAD / DXFs</li> <li>MuJoCo XML &amp; Control Code and other Jupyter Notebooks</li> <li>Micropython code for running the 2 servos <pre><code>from machine import Pin, PWM\nimport math\nimport time\n\n# Gait parameters\nAMPLITUDE = 60 * math.pi / 180\nFREQUENCY = 2.5\nPHASE_OFFSET = 0.25\nLEG_BIAS = 60 * math.pi / 180\n\n# Servo setup\nright_servo = PWM(Pin(12), freq=50)\nleft_servo = PWM(Pin(13), freq=50)\n\n# Phase state\nright_phase = 0\nleft_phase = -1\nstart_time = time.ticks_ms()\n\ndef angle_to_duty(angle_rad):\n    \"\"\"Convert angle in radians to PWM duty (40-115 range for -90\u00b0 to +90\u00b0)\"\"\"\n    degrees = angle_rad * 180 / math.pi\n    degrees = max(-90, min(90, degrees))\n    return int(40 + (degrees + 90) * 0.417)\n\ndef update():\n    \"\"\"Call this in main loop\"\"\"\n    global right_phase, left_phase\n\n    # Time calculation\n    t = time.ticks_diff(time.ticks_ms(), start_time) / 1000.0\n    dt = 0.02  # 50Hz update = 20ms\n\n    # Ramp up amplitude\n    current_amp_\n\n\n# Main loop\nwhile True:\n    update()\n    time.sleep_ms(20)\n</code></pre></li> <li>Presentation:</li> </ul>"},{"location":"#error-analysis-sim-to-real-gap","title":"Error Analysis (Sim-to-Real Gap)","text":"<p>Several factors contribute to the residual mismatch between simulation and hardware performance:</p> <ol> <li> <p>Simplified contact model    MuJoCo\u2019s default contact model uses relatively simple Coulomb friction and normal force approximations. Real foot\u2013ground interactions involve micro-interlocking, surface wear, and anisotropic friction, especially with laminated cardboard and tape. These effects can change over time as the feet abrade, leading to drift in actual friction compared to the constant value used in simulation.</p> </li> <li> <p>Servo delay and non-ideal dynamics    Our servo model assumes a first-order response with fixed gains and ignores deadband, backlash, and non-linear torque\u2013speed characteristics. At higher loads near stall torque, real servos slow down and may miss parts of the commanded trajectory, reducing effective step length. Including a more detailed servo torque\u2013speed curve and backlash in the model would likely improve fidelity.</p> </li> <li> <p>Material fatigue and anisotropy    Cardboard laminates are directionally dependent (grain direction) and exhibit plastic deformation and stiffness degradation after repeated loading. Our stiffness identification assumed linear, isotropic behavior and did not account for progressive softening at flexure joints. Over multiple trials, we observed slight \u201csagging\u201d of the legs, which changed the neutral angle and effective lever arms.</p> </li> <li> <p>Unmodeled environmental effects    Variations in surface roughness, dust, and humidity affect friction. Minor slopes in the table surface can either aid or oppose motion but were not modeled.</p> </li> </ol>"},{"location":"#closing-the-gap","title":"Closing the Gap","text":"<p>To reduce these errors, future work could:</p> <ul> <li>Implement a more detailed friction model in simulation, possibly with velocity-dependent friction and anisotropy.</li> <li>Use calibrated servo models derived from torque\u2013speed characterization and backlash measurements.</li> <li>Introduce probabilistic or distributional parameters for stiffness and friction to reflect fabrication variability.</li> <li>Incorporate closed-loop identification, where simulation parameters are tuned automatically to minimize error between simulated and measured trajectories.</li> </ul>"},{"location":"#impact-conclusion","title":"Impact &amp; Conclusion","text":"<p>This project demonstrates that foldable, cardboard-based mechanisms can support non-trivial bio-inspired walking behaviors when combined with simple actuation and careful modeling. By pivoting from high-energy jumping to quasi-static walking, we were able to:</p> <ul> <li>Build and iterate on a grasshopper-inspired hind-leg design using only low-cost fabrication tools (laser cutting and lamination).</li> <li>Identify mechanical parameters governing stiffness, damping, and friction through simple experiments.</li> <li>Construct a MuJoCo model that, after calibration and parameter sweep, predicts walking distance within approximately 5\u201322% of the physical robot over a 10-second horizon.</li> <li>Use simulation-based global optimization to discover effective gaits without exhaustive physical testing.</li> </ul> <p>Beyond serving as a course project, this work fits into a wider movement toward origami and foldable robots that are cheap, scalable, and deployable in large numbers for exploration, inspection, or education. Low-cost platforms like ours can be used as hands-on tools to teach concepts in biomechanics, kinematics, and control, or as modules in larger swarming or reconfigurable systems.</p> <p>In summary, the grasshopper inspired foldable walking robot illustrates how mechanical intelligence embodied in geometry, stiffness, and friction can produce useful locomotion with minimal actuation and control. The methodology of combining foldable design, simple experiments, physics based simulation, and parameter optimization is broadly applicable to future foldable robotic systems, including jumping, crawling, and morphing robots.</p>"},{"location":"#course-info","title":"Course Info","text":"<ul> <li>Course: RAS 557 \u2013 Foldable Robotics</li> <li>Semester: Fall 2025</li> <li>Instructor: Prof. Daniel Aukes</li> </ul>"},{"location":"charts/","title":"Charts","text":"<pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre>"},{"location":"esp-32-table/","title":"ESP32 Table","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Found on Espressif.com ESP32-S3-WROOM-1-N4 Datasheet URL ? Do not paste links directly into the table.  Use a link ESP32 S3 Datasheet URL ? Has more detail on functions ESP32 S3 Technical Reference Manual URL ? Has details on I/O multiplexing, USB, and others Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find on Digikey, Jameco, MPJA, or octopart Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? as found in datasheet Module # Available Needed Associated Pins (or * for any) UART ? ? ? external SPI* ? ? ? I2C ? ? ? GPIO ? ? ? ADC ? ? ? LED PWM ? ? ? Motor PWM ? ? ? USB Programmer ? 1 ? ... <p>* The ESP32-S2 has multiple SPI interfaces, but some are for internal use</p>"},{"location":"pic-table/","title":"PIC Table","text":"ESP Info Answer Help Model ? Include the entire part number (leave off any letters at the end that specify the package type) Product Page URL ? Do not paste links directly into the table.  Use a link Datasheet URL(s) ? Do not paste links directly into the table.  Use a link Application Notes URL(s) ? Do not paste links directly into the table.  Use a link Vendor link ? Digikey, Jameco, etc.  Do not paste links directly into the table.  Use a link Code Examples ? url(s) for libraries on github or other sites related to the microcontroller and your planned peripherals External Resources URL(s) ? Search on Google and YouTube for other resources for each specific microcontroller. Unit cost ? Find in the Microchip online store, or Digikey Absolute Maximum Current for entire IC ? Find in the microcontroller datasheet Supply Voltage Range ? Min / Nominal / Max / Absolute Max, as found in datasheet Absolute Maximum current  (for entire IC) ? as found in datasheet Maximum GPIO current  (per pin) ? as found in datasheet Supports External Interrupts? ? as found in datasheet Required Programming Hardware, Cost, URL ? found on the microcontroller's product page Works with MPLabX? ? Required.  See Microchip Development Tools Works with Microchip Code Configurator? ? Can be validated in MPLabX.  Screenshot required. Module # Available Needed Associated Pins (or * for any) GPIO ? ? ? ADC ? ? ? UART ? ? ? SPI ? ? ? I2C ? ? ? PWM ? ? ? ICSP ? 1 ? ... ... ... ..."},{"location":"second-page/","title":"Midterm Project Report","text":""},{"location":"second-page/#midterm-project-report","title":"Midterm Project Report","text":"<p>RAS 557 Foldable Robotics Group 8</p> <p>Vamshi Narayana Babu</p> <p>Shawn Dimang</p> <p>Sameerjeet Singh Chhabra</p>"},{"location":"second-page/#project-goal","title":"Project Goal","text":"<p>We aim to study and replicate the biomechanics of the grasshopper\u2019s hind-leg jumping mechanism \u2014 specifically how its flexible exoskeletal structures and elastic energy storage contribute to powerful, efficient jumps across different terrains. Our goal is to translate these biological principles into an engineered system: a foldable, bio-inspired jumping mechanism that uses flexible materials to store and release energy efficiently.</p> <p>Research question: How can bio-inspired grasshopper hind leg mechanisms use flexible material to replicate jumping?</p>"},{"location":"second-page/#designprototype","title":"Design/Prototype:","text":"<p>A foldable, flexible-material jumping leg inspired by grasshopper biomechanics, which demonstrates high energy efficiency and robustness on multiple surfaces.</p>"},{"location":"second-page/#why-this-matters","title":"Why this matters:","text":"<p>Grasshoppers achieve some of the most efficient power-to-mass jump performances in nature by combining stiff cuticular structures with compliant resilient pads and mechanical latches. Translating this system into a foldable robotic mechanism offers insight into low-cost, lightweight, and high-power actuation \u2014 especially valuable for small mobile robots or deployable exploration systems where energy storage and terrain adaptability are key.</p>"},{"location":"second-page/#scope","title":"Scope","text":"<p>To keep the project feasible within an 8-week semester, we are constraining our study to the hind-leg jumping mechanism of the grasshopper and its translation into a single foldable prototype leg. Although we will study and model one hind leg in detail (to understand its mechanics, forces, and energy storage), the prototype will feature two synchronized hind legs to better replicate grasshopper-like jumping dynamics. Instead of attempting to replicate full-body dynamics or flight trajectories, our focus is on energy storage, release, and takeoff efficiency. The system will be modeled as a foldable linkage with a compliant flexure acting as the energy storage element, using accessible materials (YET TO BE DECIDED). Analytical and simulation-based modeling will guide parameter selection (spring stiffness, leg angle, and latch geometry), followed by one physical prototype for experimental validation of jump height, distance, and efficiency. This constrained scope allows us to deliver measurable results\u2014quantitative tests of how flexible materials influence jump performance\u2014while staying within realistic fabrication, testing, and reporting timelines.</p>"},{"location":"second-page/#impact","title":"Impact","text":"<p>This project is both scientifically interesting and practically relevant. Nature\u2019s jumping mechanisms are highly optimized for power density and efficiency\u2014understanding and replicating them can inspire more energy-efficient and lightweight robotic systems. Today, there is growing interest in micro-robots and field-deployable systems (for inspection, search-and-rescue, and space exploration) that need efficient motion in variable terrain. Advances in origami-inspired design, flexible composites, and low-cost laser cutting now make it possible to model and build small-scale bio-inspired mechanisms accurately. The broader impact of this work lies in improving terrain-adaptive, power-efficient locomotion. By demonstrating that foldable, flexible designs can reproduce the performance of natural jumpers, the project can inform new directions in soft robotics, deployable mechanisms, and sustainable material use for robotics education and research.</p>"},{"location":"second-page/#team-fit","title":"Team Fit","text":"<p>Answering this question aligns closely with our team\u2019s interests in biomechanics, energy-efficient robotics, and material-based actuation. It combines our background knowledge in mechanical design and dynamics with our curiosity about how biological systems achieve high performance through structure rather than complex control. The project lets us apply skills in modeling (linkage kinematics, spring energy analysis), rapid prototyping (foldable and flexible fabrication), and experimental testing (high-speed motion capture, efficiency measurement). Our interest in using minimal actuation and maximizing mechanical intelligence matches the essence of grasshopper jumping\u2014where morphology and material properties, not electronics, drive performance. By focusing on this topic, we can deepen our understanding of how mechanical design and material selection together enable efficient locomotion, which directly supports future work in foldable robotics or bioinspired design research.</p>"},{"location":"second-page/#topic-fit","title":"Topic Fit","text":"<p>Our research question directly leverages foldable robotics principles as both a modeling and fabrication framework. The grasshopper leg will be represented as a foldable linkage system\u2014a simplified mechanical analog of the femur-tibia assembly\u2014with compliant joints and elastic folds serving as the energy storage and release elements. Using origami-inspired design techniques, we can approximate complex 3D motions with planar folds that are easy to fabricate, lightweight, and capable of storing strain energy within their material layers. Foldable mechanisms also make it possible to integrate stiffness variation and latching behavior without bulky hardware\u2014mirroring the biological combination of hard cuticle and soft resilin in the grasshopper leg. In this way, foldable robotics is not only a fabrication method but also a conceptual tool for exploring how geometry and material flexibility interact to produce efficient motion.</p>"},{"location":"second-page/#background","title":"Background","text":"<p>(a) Plots the vertical (y) vs. horizontal (x) displacement of the grasshopper\u2019s center of mass during take-off. The linear fit shows a take-off angle of \u2248 72.6 \u00b1 0.06\u00b0, representing the direction of launch. (b) Shows total displacement r(t) vs. time, with a linear fit for take-off speed \u2248 3.24 \u00b1 0.03 m s\u207b\u00b9. (c) Illustrates the study organisms \u2013 the grasshopper (Melanoplus femurrubrum) and its predator (Pisaurina mira). Panels A\u2013D show confocal micrographs of the locust\u2019s hind femur, focusing on the semi-lunar process \u2014 the key elastic storage structure responsible for powering the jump.</p> <p></p> <ul> <li>(A, B) show external (medial and lateral) views with the semi-lunar process highlighted.</li> <li>(C, D) show internal (medial and lateral) cross-sections, where the blue-shaded area marks regions rich in resilin, a highly elastic protein embedded within the hard chitinous cuticle.</li> <li> <p>The yellow arrows indicate the direction of deformation during energy storage.</p> </li> <li> <p>A high-speed camera (500 fps) captures the take-off sequence of a locust over 0\u201352 ms. The frames show the progression from the pre-loading phase (t = 0 ms) through leg extension (\u2248 40 ms) to airborne take-off (~ 52 ms).</p> </li> <li>Plots the angles of the body\u2013femur, femur\u2013tibia, tibia\u2013tarsus, and tarsus\u2013ground as functions of time (0\u201360 ms).</li> </ul>"},{"location":"second-page/#discussion-value-of-each-paper","title":"Discussion \u2013 Value of Each Paper","text":"<p>1) Grasshoppers alter jumping biomechanics to enhance escape performance under chronic risk of spider predation - Dror Hawlena This paper provides precise take-off kinematics for grasshoppers using high-speed imaging. The authors measured a take-off speed of 3.24 m/s and angle of 72.6\u00b0, which define realistic performance targets for bio-inspired jumpers. Their findings show how grasshoppers adjust joint angles and pre-loading based on environmental pressure, demonstrating the importance of adaptive biomechanics. For our project, these data guide the target motion and efficiency benchmarks for the foldable leg design, ensuring the prototype mimics natural speed and trajectory.</p> <p>2) Biomechanical and dynamic mechanism of locust take-o\ufb00 - Chen et al., 2014 Chen et al. (2014) present a dynamic model of locust take-off mechanics, combining kinematic data and force analysis. Their high-speed footage (0\u201352 ms) and joint-angle plots reveal how elastic energy stored in the semi-lunar process converts to rapid extension and lift. The study quantifies energy output (~10\u201314 mJ) and ground-reaction forces (8\u201310\u00d7 body weight), giving mechanical parameters for energy release and spring stiffness.</p> <p>3) Dynamic model and performance analysis of a rigid\u2013flexible coupling four-bar leg for a small bio-inspired jumping robot. - Zhang, J., Chen, W., Wang, J., &amp; Liu, Z. (2019) Zhang et al. developed a rigid\u2013flexible coupled four-bar leg for a small jumping robot, showing that incorporating compliant elements improves jump stability and distance. Their model demonstrates how flexibility can increase energy storage and recovery, especially on uneven terrain. This research directly parallels our project\u2019s intent to use foldable, flexible materials to improve energy efficiency and multi-terrain performance.</p> <p>4) Design of a Grasshopper-like Jumping Mechanism in a Biomimetic Approach. - Ero\u011flu, A. K. (2007) Ero\u011flu\u2019s thesis translates grasshopper anatomy into a functional mechanical model, detailing femur\u2013tibia geometry, link ratios, and spring mechanics. It provides the foundational parameters\u2014leg lengths, angular ranges, and material constraints\u2014that make biological motion achievable in a robotic form. For our project, this serves as the geometric and conceptual baseline for designing a foldable leg that reproduces the natural motion sequence while incorporating flexible components for energy efficiency.</p> <p>5) Locusts use a composite of resilin and hard cuticle as an energy store for jumping - Burrows, M., &amp; Sutton, G. P. (2012) Explains the material science of energy storage in insects. By quantifying stiffness differences between resilin and cuticle, it guides our flexible material selection for the foldable mechanism.</p>"},{"location":"second-page/#novelty-of-our-project","title":"Novelty of Our Project","text":"<p>Previous research has focused separately on either the biomechanics (Hawlena, Chen, Burrows) or robotic translation(Zhang, Ero\u011flu) of the grasshopper jump. Our project uniquely combines both through foldable robotics techniques and flexible materials to replicate the biological stiffness\u2013compliance composite within a single mechanism. By modeling and prototyping a foldable two-leg jumping system that adapts to different terrains, we aim to demonstrate improved jump efficiency and reusability. This integration of biological material principles, origami-inspired fabrication, and multi-terrain testing defines the novelty and relevance of our research within bio-inspired robotics.</p>"},{"location":"second-page/#estimated-goal-performance-metrics","title":"Estimated Goal Performance Metrics","text":"<p>To define target performance for our foldable, grasshopper-inspired jumping mechanism, we estimate the velocity, height, spring energy, and torque required for efficient take-off based on biological data and mechanical analogs.</p> Parameter Typical Value / Insight Source Body mass ~2\u20133 g (Schistocerca gregaria) Chen et al., 2014 Hind-leg length Femur \u2248 18 mm Tibia \u2248 22 mm Ero\u011flu 2007 Take-off speed 3.24 \u00b1 0.03 m s\u207b\u00b9 (mean measured by motion tracking) Hawlena et al., 2011 (Fig. 1b) Take-off angle 72.6 \u00b1 0.06\u00b0 from linear fit of trajectory - under threatened conditions Hawlena et al., 2011 (Fig. 1a) Take-off angle 40-50\u00b0 for maximum distance - under unthreatened conditions Hawlena et al., 2011 (Fig. 1a) Energy stored per jump 10\u201314 mJ total in both hind legs (semilunar processes + resilin pads) Chen 2014; Burrows &amp; Sutton 2012 Ground-reaction force (GRF) \u2248 8\u201310 \u00d7 body weight at take-off; impulse \u2248 2\u20135 ms duration Chen 2014 Material properties of hind-leg cuticle Composite of hard chitin (E \u2248 1\u20133 GPa) + resilin (E \u2248 1 MPa)\u2192 high elastic recovery Burrows &amp; Sutton 2012 Leg motion sequence Co-contraction \u2192 Latch hold \u2192 Tibia extension \u2192 Take-off \u2192 Reset Ero\u011flu 2007 Functional role of flexibility Elastic regions enable energy storage and fast recoil for efficient jumps Burrows &amp; Sutton 2012"},{"location":"second-page/#specifications-table","title":"Specifications Table","text":"Parameter Symbol Value Units Description / Source Mass of system (robot or equivalent) \\(m\\) 0.0025 kg Approx. grasshopper body mass (Hawlena et al., 2011; Chen et al., 2014) Take-off velocity \\(v\\) 3.24 m/s Measured mean from Hawlena et al. (2011) Take-off angle (biological case) \\(\\theta_1\\) 72.6 \u00b0 From trajectory fit in Hawlena et al. Take-off angle (optimized for range) \\(\\theta_2\\) 45 \u00b0 Theoretically optimal ballistic angle Take-off time \\(t\\) 0.05 s Time of leg extension (Chen et al., 2014) Gravity \\(g\\) 9.81 m/s\u00b2 Standard Earth gravity Spring compression distance \\(x\\) 0.01 m Estimated maximum flexure deflection (10 mm) Effective spring stiffness \\(k\\) 262 N/m From \\(k = 2E / x^2\\) using E = 13.1 mJ Elastic energy stored \\(E\\) 0.0131 J (13.1 mJ) Computed from kinetic energy Spring force at full preload \\(F_s\\) 2.62 N \\(F_s = kx\\) Moment arm (distance from joint pivot to spring line) \\(r\\) 0.015 m Approx. 15 mm from design geometry Torque per leg (cocking / release) \\(T_1\\) 0.039 N\u00b7m \\(T_1 = F_s r\\) for one leg Torque for both legs (if single motor) \\(T_2\\) 0.078 N\u00b7m \\(T_2 = 2 T_1\\) Ground reaction force (peak) \\(F_{grf}\\) 0.18 N \u2248 7\u20138\u00d7 body weight (Chen et al., 2014) Vertical velocity component (72.6\u00b0) \\(v_y\\) 3.09 m/s Horizontal velocity component (72.6\u00b0) \\(v_x\\) 0.95 m/s Jump height (72.6\u00b0) \\(h\\) 0.49 m \\(h = v_y^2 / 2g\\) Jump range (72.6\u00b0) \\(R\\) 0.61 m \\(R = v^2 \\sin(2\\theta)/g\\) Jump range (45\u00b0) \\(R_{max}\\) 1.07 m Maximum theoretical range"},{"location":"second-page/#mechanism-solidworks-and-cardboard-design","title":"Mechanism: Solidworks and Cardboard Design","text":""},{"location":"second-page/#kinematic-model","title":"Kinematic Model","text":"<p>Jacobian Calculations 4 Bar JupyterLab</p> <ul> <li>Kinematics and Dynamics</li> </ul>"},{"location":"second-page/#7-discussion","title":"7. Discussion","text":""},{"location":"second-page/#81-degrees-of-freedom-and-motors","title":"8.1 Degrees of freedom and motors","text":"<ul> <li>Per leg linkage: planar 4-bar (or equivalent) with 2 DOF. (2 motors)</li> <li>Two legs coupled on a common shaft \u2192 2 actuated DOF total for cocking.</li> <li>Latch adds a binary state (locked/unlocked). Release can be via the same servo (cam/tab) or a tiny solenoid/micro-servo (not counted as a continuous DOF).</li> <li>Remaining states (tibia extension during jump, body pitch) are determined passively by geometry, stored energy, and ground contact\u2014no continuous actuation needed.</li> <li>Motors: 1\u00d7 SG90 to preload both legs (or 2\u00d7 SG90, one per leg, for margin). We arrived at \u201c1 DOF actuation\u201d by constraining both legs to the same preload shaft (mechanical coupling) and using a latch to time the release.</li> </ul>"},{"location":"second-page/#82-how-we-estimated-end-effector-forces","title":"8.2 How we estimated end-effector forces","text":"<ul> <li>From literature, peak vertical GRF is ~6\u201310\u00d7 body weight.</li> <li> <p>Using our mass \\(m=0.0025\\) kg, take-off time \\(t \\approx 0.05\\) s, and vertical velocity component  \\(v_y\\):   \\(\\(a_y = v_y / t\\)\\) and \\(\\(F = m(a_y + g)\\)\\) \u2192 0.14\u20130.18 N (angle-dependent: ~0.14 N at 45\u00b0, ~0.18 N at 72.6\u00b0).</p> </li> <li> <p>This force times the joint moment arm gave joint torque used for sizing the spring and the cocking servo.</p> </li> </ul>"},{"location":"second-page/#83-how-we-estimated-end-effector-speeds","title":"8.3 How we estimated end-effector speeds","text":"<ul> <li>We decomposed measured take-off speed \\(v=3.24\\) m/s into components:     \\(\\(v_y = v \\sin \\theta, v_x = v \\cos \\theta\\)\\)</li> <li>At 72.6\u00b0: \\(v_y \\approx 3.09\\) m/s, \\(v_x \\approx 0.95\\) m/s.</li> <li>At 45\u00b0: \\(v_y = v_x \\approx 2.29\\) m/s.</li> <li>For leg tip speed we used Chen et al. timing: rapid femur\u2013tibia extension of ~100\u00b0 (\\(\\approx 1.75\\) rad) over ~15 ms \u2192 \\(\\omega \\approx 116\\) rad/s. With tibia length L \\(\\approx 22\\) mm, tip speed \\(v_{tip} \\approx \\omega L \\approx 2.5\\) m/s, consistent with COM speed.</li> </ul>"},{"location":"second-page/#references","title":"References","text":"<p>Chen, DS., Yin, JM., Chen, KW. et al. Biomechanical and dynamic mechanism of locust take-off. Acta Mech Sin 30, 762\u2013774 (2014). https://doi.org/10.1007/s10409-014-0065-2</p> <p>Hawlena, D., Kress, H., Dufresne, E.R. and Schmitz, O.J. (2011), Grasshoppers alter jumping biomechanics to enhance escape performance under chronic risk of spider predation. Functional Ecology, 25: 279-288. https://doi.org/10.1111/j.1365-2435.2010.01767.x</p> <p>Konez Ero\u011flu, A. (2007). Development and Analysis of Grasshopper-Like Jumping Mechanism in Biomimetic Approach (Order No. 31669257). Available from ProQuest Dissertations &amp; Theses Global. (3122726176).</p> <p>Malcolm Burrows, Gregory P. Sutton; Locusts use a composite of resilin and hard cuticle as an energy store for jumping and kicking. J Exp Biol 1 October 2012; 215 (19): 3501\u20133512. doi: https://doi.org/10.1242/jeb.071993</p> <p>Zhang, ZQ., Yang, Q., Zhao, J. et al. Dynamic model and performance analysis of rigid-flexible coupling four-bar leg mechanism for small scale bio-inspired jumping robot. Microsyst Technol 25, 3269\u20133285 (2019). https://doi.org/10.1007/s00542-019-04546-5</p>"},{"location":"component-selection-example/","title":"Component Selection Example","text":""},{"location":"component-selection-example/#examples","title":"Examples","text":""},{"location":"component-selection-example/#style-1","title":"Style 1","text":"<p>This is the example found in the assignment, uses more html</p> <p>Table 1: Example component selection</p> <p>External Clock Module</p> Solution Pros Cons Option 1. XC1259TR-ND surface mount crystal$1/eachlink to product * Inexpensive[^1]* Compatible with PSoC* Meets surface mount constraint of project * Requires external components and support circuitry for interface* Needs special PCB layout. * Option 2. * CTX936TR-ND surface mount oscillator * $1/each * Link to product * Outputs a square wave * Stable over operating temperature  * Direct interface with PSoC (no external circuitry required) range * More expensive * Slow shipping speed <p>Choice: Option 2: CTX936TR-ND surface mount oscillator</p> <p>Rationale: A clock oscillator is easier to work with because it requires no external circuitry in order to interface with the PSoC. This is particularly important because we are not sure of the electrical characteristics of the PCB, which could affect the oscillation of a crystal. While the shipping speed is slow, according to the website if we order this week it will arrive within 3 weeks.</p>"},{"location":"component-selection-example/#style-2","title":"Style 2","text":"<p>Also acceptable, more markdown friendly</p> <p>External Clock Module</p> <ol> <li> <p>XC1259TR-ND surface mount crystal</p> <p></p> <ul> <li>$1/each</li> <li>link to product</li> </ul> Pros Cons Inexpensive Requires external components and support circuitry for interface Compatible with PSoC Needs special PCB layout. Meets surface mount constraint of project </li> <li> <p>CTX936TR-ND surface mount oscillator</p> <p></p> <ul> <li>$1/each</li> <li>Link to product</li> </ul> Pros Cons Outputs a square wave More expensive Stable over operating temperature Slow shipping speed Direct interface with PSoC (no external circuitry required) range </li> </ol> <p>Choice: Option 2: CTX936TR-ND surface mount oscillator</p> <p>Rationale: A clock oscillator is easier to work with because it requires no external circuitry in order to interface with the PSoC. This is particularly important because we are not sure of the electrical characteristics of the PCB, which could affect the oscillation of a crystal. While the shipping speed is slow, according to the website if we order this week it will arrive within 3 weeks.</p>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/","title":"Motor","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#ras-557-parameter-identification","title":"RAS 557 - Parameter Identification","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#data-collection-setup-and-steps","title":"Data Collection Setup and Steps","text":"<ul> <li> <p>Setup. SG90 servo with a cylindrical \u201cbattery\u201d load; rig placed on a table and weighted down to suppress base motion.</p> </li> <li> <p>Camera. Phone on a fixed stand 12 in from the link CoM; optical axis normal to the motion plane.</p> </li> <li> <p>Wiring. Battery mass measured and attached to the horn using wires (minimal compliance).</p> </li> <li> <p>Command. Square-wave position command (A, f, w, b, t0) repeated for several cycles.</p> </li> <li> <p>Tracking. Video \u2192 Tracker \u2192 CSV (time, feature points) \u2192 angle reconstruction.</p> </li> <li> <p>Assumptions. Planar motion; negligible backlash; no self-collision; gravity only; measurement noise is zero-mean.</p> </li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#battery-datasheet","title":"Battery Datasheet","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#servo-motor-and-battery","title":"Servo motor and Battery","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#setup-for-data-collection","title":"Setup for Data Collection","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#video-used-for-data-tracking","title":"Video Used for Data Tracking","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#model-chosen-rationale","title":"Model Chosen &amp; Rationale","text":"<ul> <li>Plant. 1-DOF hinge with lumped inertia of the \u201cbattery\u201d and viscous damping b_act</li> <li>Actuator law. DC-motor + gear train</li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#objective-minimize-angle-rmse-between-simulated-and-measured-angles-on-the-data-time-grid","title":"Objective. Minimize angle RMSE between simulated and measured angles on the data time grid:","text":"<ul> <li>Algorithm. scipy.optimize.least_squares on variables [Kp, b_act] with bounds; simulation re-run per evaluation; sim angles interpolated to t_data.</li> </ul> <p>Units. Fit in radians; report RMSE in degrees.</p> <pre><code>import pandas\nimport scipy.signal as ss\nimport scipy.optimize as so\nimport numpy\nimport matplotlib.pyplot as plt\nimport math\n\ndata = pandas.read_csv('/Users/vamshin24/Downloads/data_tracker.csv')\ndata.columns\n</code></pre> <pre><code>Index(['t', 'x', 'y', 'x.1', 'y.1'], dtype='object')\n</code></pre> <pre><code>t = data['t']\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#findind-the-centre-of-rotation","title":"Findind the centre of rotation","text":"<pre><code>xini = data['x'].mean()\nyini = data['y'].mean()\nini = numpy.array([xini,yini])\nprint(ini)\n</code></pre> <pre><code>[3.27817355 5.09860331]\n</code></pre> <pre><code>def fun(guess):\n# break out guess into two variables, x0 and y0\n    x0,y0 = guess\n    # start with zero error\n    error = 0\n    # sum the squared length to point 1 over all time and add to error\n    error += ((data['x']-x0)**2+(data['y']-y0)**2).sum()\n    # sum the squared length to point 2 over all time and add to error\n    error += ((data['x.1']-x0)**2+(data['y.1']-y0)**2).sum()\n    # take the square root\n    error = error**.5\n    # return the error\n    return error\n</code></pre> <pre><code>print(fun(ini))\n</code></pre> <pre><code>733.7143807338089\n</code></pre> <pre><code>result = so.minimize(fun,ini)\nresult\n</code></pre> <pre><code>  message: Optimization terminated successfully.\n  success: True\n   status: 0\n      fun: 708.7890367724505\n        x: [-3.489e-01  2.009e-01]\n      nit: 5\n      jac: [-7.629e-06 -7.629e-06]\n hess_inv: [[ 9.051e-01 -1.281e-01]\n            [-1.281e-01  8.271e-01]]\n     nfev: 18\n     njev: 6\n</code></pre> <pre><code>v1 = numpy.array([data['x']-result.x[0],(data['y']-result.x[1])]).T\nv2 = numpy.array([data['x.1']-result.x[0],(data['y.1']-result.x[1])]).T\n\n\nplt.plot(v1[:,0],v1[:,1])\nplt.plot(v2[:,0],v2[:,1])\nplt.plot(0,0,'ro')\nplt.axis('equal')\n</code></pre> <pre><code>(np.float64(-25.171058264005254),\n np.float64(45.66894173599475),\n np.float64(-33.60088867363819),\n np.float64(27.999111326361813))\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#the-angle-of-each-vector-can-be-computed-by-taking-the-arctan-of-the-x-and-y-components-of-vector-1-and-2","title":"The angle of each vector can be computed by taking the arctan of the x and y components of vector 1 and 2.","text":"<pre><code>theta_v1 = numpy.arctan2(v1[:,1],v1[:,0])\ntheta_v2 = numpy.arctan2(v2[:,1],v2[:,0])\nplt.plot(t,theta_v1)\nplt.plot(t,theta_v2)\n</code></pre> <pre><code>[&lt;matplotlib.lines.Line2D at 0x124b99fa0&gt;]\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#building-unwrap-function-any-value-that-jumps-more-than-between-individual-timesteps-by-the-arctan2-function-can-be-interpreted-to-actually-be-continuously-increasing-or-decreasing-past-that-value","title":"Building unwrap function -- Any value that jumps more than \u117a between individual timesteps by the arctan2 function can be interpreted to actually be continuously increasing (or decreasing) past that value.","text":"<pre><code>def unwrap(theta,period):\n#create a holder for our new theta measurement, theta2, and seed it with the initial value of theta.\n    theta2 = [theta[0]]\n    #we need to compare our current theta measurement against the previous one. thus, we store the init\n    last_theta = theta[0]\n    #create a holder for the number of times we have transitioned through another period\n    mem = 0\n    # Starting at our 2nd data point(index 1)\n    for t_ii,item in zip(t[1:],theta[1:]):\n    #compare our current theta against the last theta\n        dt = (item - last_theta)\n        #check if there is a big jump in the positive or negative direction, and if there is, subtract o\n        if dt&gt;(period/2):\n            mem-=period\n        if dt&lt;(-period/2):\n            mem+=period\n        # compute the corrected value of theta and add to theta2\n        theta2.append(item+mem)\n        # update last_theta\n        last_theta = item\n        # reform theta2 as a numpy array\n# and return it\n    theta2 = numpy.array(theta2)\n    return theta2\n</code></pre> <pre><code>theta_v1_u = unwrap(theta_v1,2*math.pi)\ntheta_v2_u = unwrap(theta_v2,2*math.pi)\n</code></pre> <pre><code>theta_v1_u-=theta_v1_u.min()\ntheta_v2_u-=theta_v2_u.min()\n\n# offset = min(theta_v1_u.min(), theta_v2_u.min())\n# theta_v1_u -= offset\n# theta_v2_u -= offset\n</code></pre> <pre><code>plt.plot(t, theta_v1_u)\nplt.plot(t, theta_v2_u)\n</code></pre> <pre><code>[&lt;matplotlib.lines.Line2D at 0x124c0e120&gt;]\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#compute-average-of-these-2-samples","title":"Compute average of these 2 samples","text":"<pre><code>theta_u = (theta_v1_u+theta_v2_u)/2\nplt.plot(t,theta_v1_u,'b:')\nplt.plot(t,theta_v2_u,'b:')\nplt.plot(t,theta_u,'r-')\n</code></pre> <pre><code>[&lt;matplotlib.lines.Line2D at 0x124caaff0&gt;]\n</code></pre> <pre><code>value = numpy.nanmax(theta_u) * 180 / math.pi\nprint(value)\n</code></pre> <pre><code>182.2804197434021\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#guessing-the-input-signal","title":"Guessing the input signal","text":"<pre><code>time_filter = t&lt;1\n</code></pre> <pre><code>jj = theta_u[time_filter] &gt; \\\n(theta_u[time_filter].max() - theta_u[time_filter].min())*.01 \\\n+ theta_u[time_filter].min()\nt_0_kk = (t[time_filter][jj]).idxmin()\nt_0 = t[t_0_kk]\nt_0\n</code></pre> <pre><code>np.float64(0.167)\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#plot-the-moment-motion-starts-on-top-of-the-adjusted-theta-values","title":"plot the moment motion starts on top of the adjusted theta values:","text":"<pre><code>plt.plot(t[time_filter],theta_u[time_filter])\nplt.plot(t[t_0_kk],theta_u[t_0_kk],'ro')\n</code></pre> <pre><code>[&lt;matplotlib.lines.Line2D at 0x124cc6f90&gt;]\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#lets-create-a-function-that-can-generate-a-step-function-with-the-following-parameters","title":"Lets create a function that can generate a step function with the following parameters","text":"<p>\u2022 A : amplitude \u2022 f : frequency \u2022 w : width (as a fraction of the full time step) of the positive portion of the square wave \u2022 b : y-offset</p> <pre><code>A = math.pi\nf = .5\nw = .5\nb = 0\ndef square(t,A,f,w,b,t_0):\n    y = (t-t_0)*f\n    y = y%1\n    y = (y&lt;w)*1\n    y = A*y +b\n    return y\n</code></pre> <pre><code>y = square(t,A,f,w,b,t_0)\nplt.plot(t[time_filter],theta_u[time_filter])\nplt.plot(t[time_filter],y[time_filter])\nplt.plot(t[t_0_kk],theta_u[t_0_kk],'ro')\n</code></pre> <pre><code>[&lt;matplotlib.lines.Line2D at 0x1251c5ee0&gt;]\n</code></pre> <p></p> <pre><code>plt.plot(t,y)\nplt.plot(t,theta_u)\n</code></pre> <pre><code>[&lt;matplotlib.lines.Line2D at 0x125248380&gt;]\n</code></pre> <p></p>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#saving-the-data","title":"Saving the data","text":"<pre><code>data = {}\ndata['A'] = A\ndata['f'] = f\ndata['b'] = b\ndata['w'] = w\ndata['t'] = t\ndata['t_0'] = t_0\ndata['theta_u'] = theta_u\nimport yaml\nwith open('servo_data_collection.yml','w') as f:\n    yaml.dump(data,f)\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#mujoco-based-model","title":"MuJoCo Based Model","text":"<pre><code>import matplotlib.pyplot as plt\nimport numpy\nimport math\nimport yaml\nimport mujoco\nimport numpy\nimport mediapy as media\n</code></pre> <pre><code>def square(t,A,f,w,b,t_0):\n    y = (t-t_0)*f\n    y = y%1\n    y = (y&lt;w)*1\n    y = A*y +b\n    return y\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#motor-modeling","title":"Motor modeling","text":"<pre><code>Vnom = 6\nG = 55.5\nt_stall = 15/100/G\ni_stall = .6\nR = Vnom/i_stall\ni_nl = .2\nw_nl = .66*1000*math.pi/180*G\nkt = t_stall/ i_stall\nkv= Vnom/w_nl\nke = kt\nb = kt*i_nl/w_nl\nts = 1e-4\n</code></pre> <pre><code>with open('servo_data_collection.yml') as f:\n    servo_data = yaml.load(f,Loader=yaml.Loader)\n</code></pre> <pre><code>t_data  = numpy.asarray(servo_data['t'], dtype=float).ravel()    \nt_data.shape\n</code></pre> <pre><code>(484,)\n</code></pre> <pre><code>dt_data = (t_data[-1]-t_data[0])/len(t_data)\n</code></pre> <pre><code>q_data = numpy.asarray(servo_data['theta_u'], dtype=float).ravel().T\nq_data.shape\n</code></pre> <pre><code>(484,)\n</code></pre> <pre><code>desired = square(t_data,A=servo_data['A'],\nf = servo_data['f'],w=servo_data['w'],\nb=servo_data['b'],t_0=servo_data['t_0'])\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#building-the-body-of-battery-length-5050mm-width-145mm-weight-0024kg","title":"Building the body of battery (length: 50.50mm, width = 14.5mm, weight = 0.024kg)","text":"<pre><code>render_width = 800\nrender_height = 600\nxml_template = \"\"\"\n&lt;mujoco&gt;\n    &lt;visual&gt;&lt;global offwidth=\"{render_width}\" offheight=\"{render_height}\" /&gt;&lt;/visual&gt;\n    &lt;option timestep=\"{ts}\"/&gt;\n    &lt;worldbody&gt;\n        &lt;light name=\"top\" pos=\"0 0 10\"/&gt;\n        &lt;body name=\"body_1\" pos=\"0 0 0\" axisangle=\"1 0 0 0\"&gt;\n            &lt;joint name=\"joint_1\" type=\"hinge\" axis=\"1 0 0\" pos=\"0 0 0\"/&gt;\n            &lt;geom type=\"cylinder\" size=\".00725 .025\" pos=\"0 0 0\" rgba=\"0 1 1 1\"\n                mass=\"0.024\"/&gt;\n            &lt;geom type=\"cylinder\" size=\".0025 .0025\" pos=\"0 0 .024\" rgba=\"0 1 1 1\"\n                mass=\"0\"/&gt;\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n&lt;actuator&gt;\n    &lt;motor name=\"motor_1\" joint=\"joint_1\"/&gt;\n&lt;/actuator&gt;\n&lt;/mujoco&gt;\n\"\"\"\n</code></pre> <pre><code>xml = xml_template.format(ts = ts, render_width = render_width, render_height = render_width)\n</code></pre> <pre><code>model = mujoco.MjModel.from_xml_string(xml)\ndata = mujoco.MjData(model)\nrenderer = mujoco.Renderer(model,width=render_width,height=render_height)\nduration = t_data[-1] # (seconds)\nframerate = 30 # (Hz)\ndata_rate = 1/dt_data\nprint(duration,data_rate)\n</code></pre> <pre><code>8.06 60.04962779156327\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#function-that-generates-a-controller-callback-function-and-runs-the-simulation-returning-the-time-vector-and-position-vector-for-joint_1","title":"function that generates a controller callback function and runs the simulation, returning the time vector and position vector for joint_1 .","text":"<pre><code>import numpy as np\ndef run_sim(kp, b_act, render=False, video_filename=None):\n    V_supply = 5.0\n\n    def mycontroller1(model, data):\n        # PD-like motor model -&gt; torque\n        w = data.qvel[0]                               # joint speed\n        actual = data.qpos[0]                          # joint angle\n        t = data.time\n        desired = square(t,\n                         A=servo_data['A'],\n                         f=servo_data['f'],\n                         w=servo_data['w'],\n                         b=servo_data['b'],\n                         t_0=servo_data['t_0'])\n        error = desired - actual\n        V = kp * error\n        # saturate to supply\n        V = max(-V_supply, min(V_supply, V))\n        # simple DC motor back-EMF + viscous load (all in joint space)\n        torque = (kt * (V - ke * w * G) / R - b_act * w * G) * G\n        data.ctrl[0] = torque\n\n    frames = []\n    qs, ws, ts = [], [], []\n\n    # --- initialize state ---\n    mujoco.mj_resetData(model, data)\n\n    # register controller once\n    mujoco.set_mjcb_control(mycontroller1)\n    try:\n        while data.time &lt; duration:\n            mujoco.mj_step(model, data)\n\n            # record state at data_rate\n            if len(ts) &lt; data.time * data_rate:\n                ts.append(data.time)\n                qs.append(data.qpos.copy())\n                ws.append(data.qvel.copy())\n\n            # grab frames at framerate\n            if render and len(frames) &lt; data.time * framerate:\n                renderer.update_scene(data)\n                pixels = renderer.render()             # HxWx3 uint8\n                frames.append(pixels)\n    finally:\n        # ALWAYS clear the callback\n        mujoco.set_mjcb_control(None)\n\n    # numpy-ify after loop\n    ts = np.asarray(ts)\n    qs = np.asarray(qs)\n    ws = np.asarray(ws)\n\n    # write video ONCE after loop\n    if render and video_filename is not None:\n        # Try H.264 first; if your ffmpeg lacks the proper encoder/flags, fall back to webm\n        try:\n            media.show_video(frames, fps = framerate,codec='gif')\n        except RuntimeError as e:\n            print(\"H.264 encode failed, falling back to WebM (VP9). Error:\", e)\n            alt_name = video_filename.rsplit('.', 1)[0] + '.webm'\n            media.show_video(frames, fps = framerate,codec='gif')\n            video_filename = alt_name\n\n    return np.asarray(ts), np.asarray(qs), frames if render else []\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#for-kp-15","title":"For Kp = 15","text":"<pre><code>t, q, frames = run_sim(kp=15, b_act=b, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#model-vs-data-plot","title":"Model vs Data Plot","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#figure-contents","title":"Figure contents:","text":"<ul> <li>\u2013 Control (desired): square-wave command;</li> <li>\u2013 Actual (data): reconstructed angle;</li> <li> <p>\u2013 Sim: model output with fitted parameters.</p> </li> <li> <p>Style. Labeled axes (time [s], angle [rad]), distinct linestyles/colors, legend, and title \u201cServo Tracking: Data vs Model\u201d.</p> </li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#for-kp-1-and-dampening-is-b02","title":"For Kp = 1 and dampening is b*0.2","text":"<pre><code>import scipy.optimize as so\ndef fun(vars):\n    k,b = vars\n    t, q, frames = run_sim(kp=k, b_act=b, render=True, video_filename='output1.mp4')\n    error = q-q_data\n\n    error = error**2\n    error = error.sum()\n    error = error**.5\n    print(k,b,error)\n    return int(round(error))\n\n# def residuals(vars_):\n#     kp = float(vars_[0])\n#     b_act = float(vars_[1])\n\n#     # unpack what run_sim returns (if it returns 3 values)\n#     t, q, _ = run_sim(kp=kp, b_act=b_act, render=False)\n\n#     # --- align to reference ---\n#     t_ref = np.asarray(t_data).ravel()\n#     q_ref = np.asarray(q_data).ravel()\n#     t_sim = np.asarray(t).ravel()\n#     q_sim = np.asarray(q).ravel()\n#     q_sim_on_ref = np.interp(t_ref, t_sim, q_sim)\n#     e = q_sim_on_ref - q_ref\n#     e = np.arctan2(np.sin(e), np.cos(e))   # wrap\n\n#     return e\n</code></pre> <pre><code>ini = [1,b*0.2]\nfun(ini)\n\n# # initial guess (kp, b_act)\n# x0 = np.array([15.0, float(b)])\n\n# # bounds are optional; adjust if needed\n# res = so.least_squares(residuals, x0, bounds=([0.0, 0.0], [200.0, 5.0]))\n# kp_fit, b_fit = res.x\n# rmse_deg = np.degrees(np.sqrt(np.mean(res.fun**2)))\n# print(\"kp:\", kp_fit, \" b_act:\", b_fit, \"  RMSE(deg):\", rmse_deg)\n</code></pre> <pre><code>1 2.8183357565468333e-07 827.7192746752488\n\n\n\n\n\n828\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#for-above-and-below-case-i-used-kp-1-and-dampening-b02-im-considering-this-as-my-ideal-and-closest-according-to-graph","title":"For above and below case I used Kp = 1 and dampening b*0.2 --- I'm considering this as my ideal and closest according to graph","text":"<pre><code>t, q, frames = run_sim(kp=15, b_act=b*0.2, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#the-fitted-model-reproduces-step-transitions-reasonably-well-and-yields-updated-motor-constants-w_nl-i_nl-k_v-consistent-with-the-identified-damping-improving-steady-state-speed-and-power-predictions-for-the-teams-full-dynamic-model","title":"The fitted model reproduces step transitions reasonably well and yields updated motor constants (W_nl, i_nl, k_v) consistent with the identified damping, improving steady-state speed and power predictions for the team\u2019s full dynamic model.","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#startpoint-correction-make-the-curves-start-at-00","title":"Start\u2010point correction (make the curves start at (0,0))","text":"<p>Problem. The data trace begins with an angle/time offset, so the first sample is not at (0 s, 0 rad).</p> <p>1) Time zeroing: shift time so the first sample is 0 <code>t_data = t_data - t_data[0]</code> 2) Angle zeroing: subtract the first measured angle (or the mean of the first 100 ms) <code>q_data = q_data - q_data[0]</code>     Also zero the sim\u2019s initial condition: set <code>data.qpos[:] = q_data[0]</code> before running.</p>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#parameter-identification","title":"Parameter Identification","text":"<pre><code>V_supply = 5\nw_nl_updated = kt*V_supply/((b*0.2)*R +kt*ke)\ni_nl_updated = w_nl_updated*(b*0.2)/kt\nkv_updated = V_supply/w_nl_updated\nprint('w_nl: ',w_nl,'w_nl(updated): ',w_nl_updated)\nprint('i_nl: ',i_nl,'i_nl(updated): ',i_nl_updated)\nprint('k_v: ',kv,'k_v(updated): ',kv_updated)\n</code></pre> <pre><code>w_nl:  639.3141050055228 w_nl(updated):  974.6256138668646\ni_nl:  0.2 i_nl(updated):  0.06097945321312409\nk_v:  0.009385058069300956 k_v(updated):  0.005130175042457902\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#_nl-no-load-angular-speed-rads-the-motors-steady-state-speed-when-supplied-with-a-given-voltage-and-no-mechanical-load-only-internal-losses","title":"\u03c9_nl = No-load angular speed (rad/s). - The motor\u2019s steady-state speed when supplied with a given voltage and no mechanical load (only internal losses).","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#i_nl-no-load-currenta-the-current-drawn-at-no-mechanical-load-it-covers-bearingfriction-windage-iron-losses","title":"i_nl = No-load current(A) - The current drawn at no mechanical load. It covers bearing/friction + windage + iron losses.","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#k_v-back-emf-constant-vsrad-the-constant-relating-motor-speed-to-generated-voltage-and-current-to-torque-in-si-k_t-k_v","title":"k_v = Back EMF Constant (V.s/rad) - The constant relating motor speed to generated voltage and current to torque (in SI, K_t = K_v)","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#discussion-answers","title":"Discussion &amp; Answers","text":""},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#1-what-could-be-improved-in-the-experiment-design","title":"1) What could be improved in the experiment design?","text":"<ul> <li>Time/angle zeroing: hard-reset time to 0 and set initial angle by averaging the first 100 ms.</li> <li>Mechanical isolation: clamp/weight the base and use a rigid horn to reduce compliance.</li> <li>Optics: fix camera at normal incidence, known distance, and use a calibration square to remove scale/tilt.</li> <li>SNR: increase lighting and frame rate; average multiple runs.</li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#2-rationale-for-the-chosen-model-and-assumptions","title":"2) Rationale for the chosen model (and assumptions)","text":"<ul> <li>Model: 1-DOF hinge with a lumped inertia load; DC-motor drive with back-EMF and viscous loss</li> <li>Why this model: minimal parameters yet captures the dominant behavior for a hobby servo under step/square commands; fast to simulate and identifiable from our data.</li> <li>Key assumptions / simplifications: planar motion; constant K_t  (SI); viscous damping only; fixed gear ratio \\(G\\); no compliance; no thermal/voltage sag; gravity only.</li> <li>References (standard): DC motor electromechanics (back-EMF + torque constant), textbook.</li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#3-why-this-fitting-method","title":"3) Why this fitting method?","text":"<ul> <li>Method: nonlinear least-squares on wrapped angle residuals.</li> <li>Justification: small parameter set (2\u20133 vars), smooth differentiable simulator, supports bounds and returns a covariance proxy.</li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#4-numerical-qualitative-fit","title":"4) Numerical &amp; qualitative fit","text":"<ul> <li>Result (example from our run): \\(k_p=1\\), (b_act approx b*0.2).</li> <li>Qualitative: plateaus match well; main error occurs at rising/falling edges (phase lag). Visual overlay shows sim (blue) hugging the actual (green) except around transitions.</li> </ul>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#5-validity-limits-where-the-model-works","title":"5) Validity limits (where the model works)","text":"<ul> <li>Good fit when: moderate speeds/torques, voltage not sagging, small accelerations, minimal stiction, no backlash; temperature roughly constant.</li> <li>Expectation: our use stays mostly inside these limits; for tasks with rapid reversals or precision near zero-velocity.</li> </ul> <pre><code># results = so.minimize(fun,x0=ini,method='nelder-mead',bounds = ((1,100),(b*.1,b*10)),\n# options={'xatol':1e-2,'fatol':1e-2})\n</code></pre> <pre><code># results\n</code></pre> <pre><code># kp_act, b_act =results.x\n# t,q,frames = run_sim(kp_act,b_act,render=True,video_filename='output.mp4')\n# plt.imshow(frames[0])\n# plt.axis('off')\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#other-exxperimentations-with-values-for-kp-2","title":"Other Exxperimentations with values, For Kp = 2","text":"<pre><code>t, q, frames = run_sim(kp=2, b_act=b, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre> <pre><code>import scipy.optimize as so\ndef fun(vars):\n    k,b = vars\n    t, q, frames = run_sim(kp=k, b_act=b, render=True, video_filename='output1.mp4')\n    error = q-q_data\n    error = error**2\n    error = error.sum()\n    error = error**.5\n    print(k,b,error)\n    return int(round(error))\n</code></pre> <pre><code>ini = [100,b]\nfun(ini)\n</code></pre> <pre><code>100 1.4091678782734167e-06 943.1230409838163\n\n\n\n\n\n943\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#kp-4","title":"Kp = 4","text":"<pre><code>t, q, frames = run_sim(kp=4, b_act=b, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#kp-20","title":"Kp = 20","text":"<pre><code>t, q, frames = run_sim(kp=20, b_act=b, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre>"},{"location":"notebooks/Assignment5_RAS557/Assignment5_RAS557/#experimenting-with-the-dampening","title":"Experimenting with the dampening","text":"<pre><code>t, q, frames = run_sim(kp=20, b_act=b*3, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre> <pre><code>t, q, frames = run_sim(kp=20, b_act=b*6, render=True, video_filename='output1.mp4')\nplt.imshow(frames[0])\nplt.axis('off')\n</code></pre> <pre><code>(np.float64(-0.5), np.float64(799.5), np.float64(599.5), np.float64(-0.5))\n</code></pre> <pre><code>print('t_data', np.shape(t_data))\nprint('desired', np.shape(desired))\nprint('q_data', np.shape(q_data))\nprint('q', np.shape(q)) \n\nq_sim = np.asarray(q).ravel()[:len(t_data)]   # drop the last sample\n\nplt.plot(t_data, q_sim,  label='sim')\nplt.plot(t_data, desired,label='control')\nplt.plot(t_data, q_data, label='actual')\nplt.legend(); plt.show()\n</code></pre> <pre><code>t_data (484,)\ndesired (484,)\nq_data (484,)\nq (485, 1)\n</code></pre>"},{"location":"notebooks/New_assignment-1/New_assignment-1/","title":"Friction","text":""},{"location":"notebooks/New_assignment-1/New_assignment-1/#part-1-data-loading-and-preprocessingexplanation","title":"Part 1: Data Loading and PreprocessingExplanation:","text":"<p>This code reads the raw spring experiment data from a csv file, removes the header row, and normalizes the time values to start from t=0. Then it plot the data for analysis</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Read the spring data\ntime = []\nposition = []\n\nwith open('spring_output.csv', 'r') as f:\n    next(f)  # Skip header\n    for line in f:\n        if line.strip():\n            parts = line.split(',')\n            time.append(float(parts[0]))\n            position.append(float(parts[1]))\n\ntime = np.array(time)\nposition = np.array(position)\n\n# Plot the data\nplt.figure(figsize=(12, 6))\nplt.plot(time, position, 'bo-', markersize=4, linewidth=1.5)\nplt.xlabel('Time (s)', fontsize=12)\nplt.ylabel('Position (m)', fontsize=12)\nplt.title('Spring Oscillation - Experimental Data', fontsize=14, fontweight='bold')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig('spring_data_plot.png', dpi=300)\nplt.show()\n\nprint(f\"Data points: {len(time)}\")\nprint(f\"Time range: {time[0]:.3f} to {time[-1]:.3f} seconds\")\nprint(f\"Position range: {position.min():.6f} to {position.max():.6f} meters\")\n</code></pre> <p></p> <pre><code>Data points: 100\nTime range: 0.000 to 3.960 seconds\nPosition range: -0.022160 to 0.025690 meters\n</code></pre>"},{"location":"notebooks/New_assignment-1/New_assignment-1/#part-2-parameter-identification-using-curve-fitting","title":"Part 2: Parameter Identification Using Curve Fitting","text":"<p>This code figures out the spring constant k_spring and damping coefficient c_damping from your experimental data. When a spring oscillates, it bounces back and forth but the motion gradually gets smaller because of damping. The code fits a mathematical curve to your data that matches this behavior. The curve has two main numbers that control its shape: zeta which controls how fast the oscillations die out, and omega_n which controls how fast the spring bounces. Once we find the best values for zeta and omega_n that match your data, we use simple formulas to calculate k_spring and c_damping. The k_spring tells you how stiff the spring is, and c_damping tells you how much resistance slows it down. The R_squared value tells you how well the fitted curve matches your actual data. A value close to 1 means the fit is very good.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.optimize import curve_fit\nfrom scipy.signal import find_peaks\n\n# System mass\nMASS = 0.257  # kg\n\n# Damped oscillator model: x(t) = A * e^(-\u03b6\u03c9\u2099t) * cos(\u03c9\u2090t + \u03c6) + offset\ndef damped_oscillation(t, A, zeta, omega_n, phi, offset):\n    omega_d = omega_n * np.sqrt(1 - zeta**2)\n    return A * np.exp(-zeta * omega_n * t) * np.cos(omega_d * t + phi) + offset\n\n# Make initial guesses for curve fitting\nA_guess = max(position) - min(position)\noffset_guess = np.mean(position)\npeaks, _ = find_peaks(position)\n\nif len(peaks) &gt; 1:\n    period = np.mean(np.diff(time[peaks]))\n    omega_n_guess = 2 * np.pi / period * 1.1\nelse:\n    omega_n_guess = 10\n\n# Fit the damped oscillation model to data\npopt, pcov = curve_fit(\n    damped_oscillation, time, position, \n    p0=[A_guess, 0.1, omega_n_guess, 0, offset_guess],\n    bounds=([0, 0, 0, -np.pi, -np.inf], [np.inf, 1, 100, np.pi, np.inf]),\n    maxfev=10000\n)\n\nA_fit, zeta_fit, omega_n_fit, phi_fit, offset_fit = popt\nperr = np.sqrt(np.diag(pcov))\n\n# Calculate physical parameters\nk_spring = MASS * (omega_n_fit ** 2)\nc_damping = MASS * 2 * zeta_fit * omega_n_fit\n\n# Calculate fit quality (R\u00b2)\nresiduals = position - damped_oscillation(time, *popt)\nr_squared = 1 - (np.sum(residuals**2) / np.sum((position - np.mean(position))**2))\n\n# Print results\nprint(\"=\" * 60)\nprint(\"SPRING PARAMETER FITTING\")\nprint(\"=\" * 60)\nprint(f\"Spring Constant (k):     {k_spring:.2f} N/m\")\nprint(f\"Damping Coefficient (c): {c_damping:.4f} N\u00b7s/m\")\nprint(f\"Damping Ratio (\u03b6):       {zeta_fit:.4f}\")\nprint(f\"Natural Frequency (\u03c9\u2099):  {omega_n_fit:.2f} rad/s\")\nprint(f\"R\u00b2 (fit quality):        {r_squared:.4f}\")\nprint(\"=\" * 60)\n\n# Plot\nt_fit = np.linspace(time[0], time[-1], 1000)\nx_fit = damped_oscillation(t_fit, *popt)\n\nplt.figure(figsize=(12, 6))\nplt.plot(time, position, 'bo', markersize=6, label='Experimental Data', alpha=0.7)\nplt.plot(t_fit, x_fit, 'r-', linewidth=2, label='Fitted Model')\nplt.xlabel('Time (s)', fontsize=12)\nplt.ylabel('Position (m)', fontsize=12)\nplt.title('Spring Damping Analysis', fontsize=14, fontweight='bold')\nplt.legend(fontsize=11)\nplt.grid(True, alpha=0.3)\n\ntextstr = f'k = {k_spring:.2f} N/m\\nc = {c_damping:.4f} N\u00b7s/m\\nR\u00b2 = {r_squared:.4f}'\nplt.text(0.02, 0.98, textstr, transform=plt.gca().transAxes, fontsize=10,\n        verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.5))\n\nplt.tight_layout()\nplt.savefig('spring_analysis.png', dpi=300)\nplt.show()\n</code></pre> <pre><code>============================================================\nSPRING PARAMETER FITTING\n============================================================\nSpring Constant (k):     38.52 N/m\nDamping Coefficient (c): 0.4762 N\u00b7s/m\nDamping Ratio (\u03b6):       0.0757\nNatural Frequency (\u03c9\u2099):  12.24 rad/s\nR\u00b2 (fit quality):        0.9641\n============================================================\n</code></pre> <p></p>"},{"location":"notebooks/New_assignment-1/New_assignment-1/#code-3-mujoco-validation","title":"Code 3: MuJoCo Validation","text":"<p>This code checks whether the k_spring and c_damping values we found in Part 2 are actually correct. It does this by creating a virtual spring in MuJoCo, which is a physics simulator that can calculate exactly how a spring should move if we know its properties. We give MuJoCo the same starting position and velocity as your real experiment, then let it simulate the motion using our fitted k_spring and c_damping values. If our fitted values are correct, the simulated motion should match your experimental data very closely. The code creates two plots. The top plot shows your experimental data and the MuJoCo simulation overlaid on each other so you can see how well they match. The bottom plot shows the error, which is the difference between experiment and simulation at each time point. We also calculate the RMSE which is the average error across all time points. A small RMSE means our fitted parameters are accurate and MuJoCo can reproduce your experiment. A large RMSE means something is wrong, either our fitting didn't work well or the real spring has more complicated behavior that our simple model doesn't capture.</p> <pre><code>import mujoco\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n# Use fitted parameters from Part 2\nMASS = 0.257\nK_SPRING = k_spring\nC_DAMPING = c_damping\n\nprint(f\"Validating: k={K_SPRING:.2f} N/m, c={C_DAMPING:.4f} N\u00b7s/m, m={MASS} kg\\n\")\n\n# Get initial conditions from experimental data\nINITIAL_POS = position[0]\nINITIAL_VEL = (position[1] - position[0]) / (time[1] - time[0])\n\n# Create MuJoCo model\nxml = f\"\"\"\n&lt;mujoco&gt;\n  &lt;option gravity=\"0 0 0\" timestep=\"0.001\"/&gt;\n  &lt;worldbody&gt;\n    &lt;body name=\"mass\" pos=\"0 0 0\"&gt;\n      &lt;joint name=\"slide\" type=\"slide\" axis=\"1 0 0\" \n             stiffness=\"{K_SPRING}\" damping=\"{C_DAMPING}\"/&gt;\n      &lt;geom type=\"box\" size=\"0.05 0.05 0.05\" mass=\"{MASS}\"/&gt;\n    &lt;/body&gt;\n  &lt;/worldbody&gt;\n&lt;/mujoco&gt;\n\"\"\"\n\nmodel = mujoco.MjModel.from_xml_string(xml)\ndata = mujoco.MjData(model)\n\n# Set initial conditions\ndata.qpos[0] = INITIAL_POS\ndata.qvel[0] = INITIAL_VEL\n\n# Run simulation\nsim_time = []\nsim_pos = []\nn_steps = int(time[-1] / 0.001)\n\nfor i in range(n_steps):\n    mujoco.mj_step(model, data)\n    if i % 10 == 0:\n        sim_time.append(data.time)\n        sim_pos.append(data.qpos[0])\n\nsim_time = np.array(sim_time)\nsim_pos = np.array(sim_pos)\n\n# Calculate error\nsim_interp = np.interp(time, sim_time, sim_pos)\nerror = position - sim_interp\nrmse = np.sqrt(np.mean(error**2))\namplitude = (np.max(position) - np.min(position)) / 2\nrmse_percent = (rmse / amplitude) * 100\n\n# Plot\nplt.figure(figsize=(14, 7))\nplt.plot(time, position, 'bo', label='Experiment', markersize=8, alpha=0.6, zorder=3)\nplt.plot(sim_time, sim_pos, 'r-', label='MuJoCo Simulation', linewidth=3, alpha=0.8, zorder=2)\nplt.xlabel('Time (s)', fontsize=12)\nplt.ylabel('Position (m)', fontsize=12)\nplt.title(f'MuJoCo Validation: k={K_SPRING:.2f} N/m, c={C_DAMPING:.4f} N\u00b7s/m, m={MASS} kg', \n          fontsize=13, fontweight='bold')\nplt.legend(fontsize=11, loc='best')\nplt.grid(True, alpha=0.3)\n\ntextstr = f'RMSE: {rmse:.6f} m ({rmse_percent:.1f}%)\\nMax Error: {np.max(np.abs(error)):.6f} m'\nplt.text(0.02, 0.98, textstr, transform=plt.gca().transAxes, fontsize=10,\n        verticalalignment='top', bbox=dict(boxstyle='round', facecolor='wheat', alpha=0.7))\n\nplt.tight_layout()\nplt.savefig('mujoco_validation.png', dpi=200)\nplt.show()\n\nprint(\"=\" * 60)\nprint(\"VALIDATION RESULTS\")\nprint(\"=\" * 60)\nprint(f\"RMSE: {rmse:.6f} m ({rmse_percent:.1f}% of amplitude)\")\nprint(f\"Max Error: {np.max(np.abs(error)):.6f} m\")\nprint(\"=\" * 60)\n</code></pre> <pre><code>Validating: k=38.52 N/m, c=0.4762 N\u00b7s/m, m=0.257 kg\n</code></pre> <p></p> <pre><code>============================================================\nVALIDATION RESULTS\n============================================================\nRMSE: 0.002025 m (8.5% of amplitude)\nMax Error: 0.006967 m\n============================================================\n</code></pre> <p>Spring Experiment: The comparison between the MuJoCo simulation and experimental spring oscillation data shows discrepancies that highlight the limitations of idealized models. The simulation assumes constant spring constant (k) and damping coefficient (c) throughout the motion, along with perfect energy conservation aside from the specified damping. However, in reality, springs exhibit nonlinear behavior where the spring constant varies with displacement, the damping coefficient changes with velocity and temperature, and additional energy dissipation occurs through air resistance, internal friction within the spring material, and energy losses at mounting points. The experimental data shows RMSE of 0.002 m (8.5% error), with the simulation capturing the general oscillatory behavior but missing subtle variations in amplitude decay and frequency. These deviations underscore that real mechanical systems involve complex, time-varying parameters and multiple energy dissipation mechanisms that cannot be fully captured by simple linear models with constant coefficients.</p>"},{"location":"notebooks/New_assignment-1/New_assignment-1/#friction-analysis","title":"Friction Analysis","text":""},{"location":"notebooks/New_assignment-1/New_assignment-1/#code-1-read-and-plot-friction-data","title":"Code 1: Read and Plot Friction Data","text":"<p>This code reads your friction experiment data from the CSV file and plots position versus time. In a friction experiment, you typically slide an object across a surface and measure how it slows down due to friction. The plot shows how the position changes over time. If friction is present, you should see the object gradually slow down, meaning the position curve becomes less steep over time. The code also calculates some basic statistics like the total distance traveled and average velocity. This gives you a sense of how much the object moved and how fast it was going. Unlike the spring data which oscillates back and forth, friction data typically shows motion in one direction that gradually comes to a stop as friction dissipates the kinetic energy.</p> <pre><code>import matplotlib.pyplot as plt\nimport numpy as np\n\n# Read the friction data\nfriction_time = []\nfriction_position = []\n\nwith open('friction_output.csv', 'r') as f:\n    next(f)  # Skip header\n    for line in f:\n        if line.strip():\n            parts = line.split(',')\n            friction_time.append(float(parts[0]))\n            friction_position.append(float(parts[1]))\n\nfriction_time = np.array(friction_time)\nfriction_position = np.array(friction_position)\n\n# Plot the data\nplt.figure(figsize=(12, 6))\nplt.plot(friction_time, friction_position, 'ro-', markersize=4, linewidth=1.5)\nplt.xlabel('Time (s)', fontsize=12)\nplt.ylabel('Position (m)', fontsize=12)\nplt.title('Friction Experiment - Position vs Time', fontsize=14, fontweight='bold')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig('friction_data_plot.png', dpi=300)\nplt.show()\n\nprint(f\"Data points: {len(friction_time)}\")\nprint(f\"Time range: {friction_time[0]:.3f} to {friction_time[-1]:.3f} seconds\")\nprint(f\"Position range: {friction_position.min():.6f} to {friction_position.max():.6f} meters\")\nprint(f\"Total displacement: {abs(friction_position[-1] - friction_position[0]):.6f} meters\")\n</code></pre> <p></p> <pre><code>Data points: 29\nTime range: 0.000 to 1.120 seconds\nPosition range: 0.000209 to 0.532000 meters\nTotal displacement: 0.531791 meters\n</code></pre>"},{"location":"notebooks/New_assignment-1/New_assignment-1/#code-2-calculate-acceleration-from-friction-data-simplified","title":"Code 2: Calculate Acceleration from Friction Data (Simplified)","text":"<p>This code calculates acceleration from your position data and then determines the friction coefficient. On a slanted surface, gravity pulls the object down the slope while friction opposes the motion. The object accelerates down the incline at a rate determined by these two competing forces. We calculate velocity by finding how position changes over time, then calculate acceleration by finding how velocity changes over time. The average acceleration tells us the net effect of gravity and friction combined. Using physics equations for motion on an incline, we can separate out the friction effect. The friction coefficient mu tells you how much friction exists between the object and the surface. A higher mu means more friction. This single number characterizes the sliding friction between your specific materials.</p> <pre><code>import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import linregress\nimport mediapy as media\n\n# Step 1: Calculate velocity\nvelocity = np.diff(friction_position) / np.diff(friction_time)\ntime_vel = friction_time[:-1]\n\n# Step 2: Fit a straight line to velocity data\nslope, intercept, r_value, p_value, std_err = linregress(time_vel, velocity)\n\n# The slope of velocity vs time IS the acceleration\nacceleration = slope\n\n# Create fitted line\nvelocity_fit = slope * time_vel + intercept\n\n\nprint(\"RESULTS\")\n\nprint(f\"Acceleration (slope of velocity): {acceleration:.4f} m/s\u00b2\")\n\n# Calculate friction coefficient\nMASS = 0.008  # kg\nANGLE = 21  # degrees\ng = 9.81  # m/s\u00b2\n\nangle_rad = np.radians(ANGLE)\nmu = (g * np.sin(angle_rad) - acceleration) / (g * np.cos(angle_rad))\n\nprint(f\"\\nFriction Coefficient (mu): {mu:.4f}\")\n\n\n# Plot velocity with fitted line\nplt.figure(figsize=(12, 6))\nplt.plot(time_vel, velocity, 'bo', markersize=6, label='Velocity Data', alpha=0.6)\nplt.plot(time_vel, velocity_fit, 'r-', linewidth=2, label=f'Linear Fit (slope = {acceleration:.4f} m/s\u00b2)')\nplt.xlabel('Time (s)', fontsize=12)\nplt.ylabel('Velocity (m/s)', fontsize=12)\nplt.title('Velocity vs Time (Linear Fit)', fontsize=14, fontweight='bold')\nplt.legend(fontsize=11)\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.savefig('friction_velocity_fit.png', dpi=300)\nplt.show()\n</code></pre> <pre><code>RESULTS\nAcceleration (slope of velocity): 0.8414 m/s\u00b2\n\nFriction Coefficient (mu): 0.2920\n</code></pre> <p></p>"},{"location":"notebooks/New_assignment-1/New_assignment-1/#code-3-mujoco-friction-simulation","title":"Code 3: MuJoCo Friction Simulation","text":"<p>This code tests if your calculated friction coefficient is correct by simulating the same experiment in MuJoCo. We create an inclined plane at 20 degrees and place an object with the same mass as your experiment on it. The object slides down under gravity while friction opposes the motion. We use the friction coefficient mu that we calculated from your experimental data. MuJoCo then simulates the physics and calculates how the object should move. We track the position along the incline over time and compare it to your experimental data. If the simulation matches your experiment well with small RMSE, then the friction coefficient we calculated is accurate. If there's a large mismatch, it suggests either the friction coefficient calculation was wrong or the real system has additional effects like air resistance or rolling friction that the simple sliding friction model doesn't capture.</p> <pre><code>MJCF = \"\"\"\n&lt;mujoco&gt;\n  &lt;asset&gt;\n    &lt;texture name=\"grid\" type=\"2d\" builtin=\"checker\" rgb1=\".1 .2 .3\"\n     rgb2=\".2 .3 .4\" width=\"300\" height=\"300\" mark=\"none\"/&gt;\n    &lt;material name=\"grid\" texture=\"grid\" texrepeat=\"6 6\"\n     texuniform=\"true\" reflectance=\".2\"/&gt;\n     &lt;material name=\"wall\" rgba='.5 .5 .5 1'/&gt;\n  &lt;/asset&gt;\n\n  &lt;default&gt;\n    &lt;geom type=\"box\" size=\".01 .01 .01\" mass=\"{mass}\"/&gt;\n    &lt;joint type=\"free\"/&gt;\n  &lt;/default&gt;\n\n  &lt;worldbody&gt;\n    &lt;light name=\"light\" pos=\"-.2 0 1\"/&gt;\n    &lt;geom name=\"ground\" type=\"plane\" size=\".5 .5 10\" material=\"grid\"\n     zaxis=\"{zaxis_x} 0 {zaxis_z}\" friction=\"{friction_coeff}\"/&gt;\n    &lt;camera name=\"y\" pos=\"-.1 -.6 .3\" xyaxes=\"1 0 0 0 1 2\"/&gt;\n    &lt;body pos=\"0 0 .0\"&gt; #front\n      &lt;joint/&gt;\n      &lt;geom name=\"front\" friction=\"{friction_coeff}\"/&gt; \n    &lt;/body&gt;\n  &lt;/worldbody&gt;\n\n&lt;/mujoco&gt;\n\"\"\"\nn_frames = 60\nheight = 300\nwidth = 300\nframes = []\n\nangle_rad = np.radians(ANGLE)\n\nxml_filled = MJCF.format(zaxis_x=-np.sin(angle_rad), zaxis_z=np.cos(angle_rad), friction_coeff=mu, mass = MASS)\nmodel = mujoco.MjModel.from_xml_string(xml_filled)\ndata = mujoco.MjData(model)\n\n# Simulate and display video.\nwith mujoco.Renderer(model, height, width) as renderer:\n  mujoco.mj_resetData(model, data)\n  for i in range(n_frames):\n    while data.time &lt; i/30.0:\n      mujoco.mj_step(model, data)\n    renderer.update_scene(data, \"y\")\n    frame = renderer.render()\n    frames.append(frame)\n\nmedia.show_video(frames, fps=30)\n</code></pre>        This browser does not support the video tag.        <pre><code>import mujoco\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# Load and simulate\nmujoco.mj_resetData(model, data)\n\nsim_times = []\nsim_positions = []\n\nfor i in range(30):\n    while data.time &lt; i/30.0:\n        mujoco.mj_step(model, data)\n    sim_times.append(data.time)\n    sim_positions.append(-data.qpos[0])  # Inverted sign\n\nsim_times = np.array(sim_times)\nsim_positions = np.array(sim_positions)\n\n# Read the friction data from CSV\nfriction_time = []\nfriction_position = []\n\nwith open('friction_output.csv', 'r') as f:\n    next(f)  # Skip header\n    for line in f:\n        if line.strip():\n            parts = line.split(',')\n            friction_time.append(float(parts[0]))\n            friction_position.append(float(parts[1]))\n\nfriction_time = np.array(friction_time)\nfriction_position = np.array(friction_position)\n\n# Plot comparison\nplt.figure(figsize=(12, 6))\nplt.plot(friction_time, friction_position, 'ro-', label='CSV Data', markersize=4)\nplt.plot(sim_times, sim_positions, 'bs-', label='MuJoCo', markersize=4)\nplt.xlabel('Time (s)')\nplt.ylabel('Position (m)')\nplt.title('Friction Experiment - Position vs Time Comparison')\nplt.legend()\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n\n# Calculate and plot MSE\nfrom scipy.interpolate import interp1d\n\n# Interpolate MuJoCo data to match CSV time points\nmujoco_interp = interp1d(sim_times, sim_positions, kind='linear', fill_value='extrapolate')\nmujoco_at_csv_times = mujoco_interp(friction_time)\n\n# Calculate MSE\nmse = np.mean((friction_position - mujoco_at_csv_times)**2)\nrmse = np.sqrt(mse)\n\nprint(f\"\\nMean Squared Error (MSE): {mse:.6e}\")\nprint(f\"Root Mean Squared Error (RMSE): {rmse:.6f} m\")\n\n# Plot residuals\nplt.figure(figsize=(12, 4))\nplt.plot(friction_time, friction_position - mujoco_at_csv_times, 'go-', markersize=3)\nplt.axhline(y=0, color='k', linestyle='--', alpha=0.3)\nplt.xlabel('Time (s)')\nplt.ylabel('Residual (m)')\nplt.title(f'Residuals (CSV - MuJoCo) | RMSE = {rmse:.6f} m')\nplt.grid(True, alpha=0.3)\nplt.tight_layout()\nplt.show()\n</code></pre> <p></p> <pre><code>Mean Squared Error (MSE): 1.471729e-03\nRoot Mean Squared Error (RMSE): 0.038363 m\n</code></pre> <p></p> <p>Friction Experiment: The comparison between the MuJoCo simulation and experimental data reveals that the simulation predicts faster acceleration and greater displacement over time, as evidenced by the consistent negative residuals. This discrepancy is physically reasonable and expected. The MuJoCo simulation models an idealized system with only the specified friction coefficient (\u03bc = 0.2347), while the real-world experiment encounters additional resistive forces such as air resistance, rolling resistance, surface irregularities, and potential energy losses through vibrations. These unmodeled dissipative effects in the physical system result in slower acceleration compared to the simulation. The RMSE of approximately 0.047 m (or 8.5% error) demonstrates that while the simplified MuJoCo model captures the primary dynamics of friction on an inclined plane, real-world uncertainties and additional resistive mechanisms introduce systematic deviations that cause the actual block to lag behind the idealized simulation.</p>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/","title":"RAS557 Assignment6 1234232638","text":""},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#ras-557-assignment-6","title":"RAS 557 Assignment 6","text":""},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#vamshi-narayana-babu","title":"Vamshi Narayana Babu","text":""},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#asu-id-1234232638","title":"ASU ID : 1234232638","text":"<pre><code>import mujoco\nimport mediapy as media\nimport numpy as np\nimport math\nimport matplotlib.pyplot as plt\n</code></pre>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#motor-and-simulation-paramters-t_stall-0015g-i_stall-4","title":"Motor and Simulation Paramters (t_stall = 0.015/G, i_stall = .4)","text":"<p>I have used motor parameters which I found in assignment5 (i_nl, w_nl, kv).I have changed the t_stall and i_stall. Now they are t_stall = 0.015/G, and i_stall = .4. </p> <pre><code>V = 6\nG = 55.5\nt_stall = 0.015/G\ni_stall = .4\nR = V/i_stall\ni_nl = 0.0609\nw_nl = 974.6256138668646\nkt = t_stall/ i_stall\nkv= 0.005130175\nke = kt\nb = kt*i_nl/w_nl\nts = 1e-4\nomega_n = 45.0\nzeta = 0.6\n\nframe_rate = 30\nt_max = 5\n</code></pre> <p>Model Summary: Model consists of a  trunk and a two-link serial arm. The trunk moves along a prismatic joint on the z-axis, and the arm links are connected by hinge joints rotating about the y-axis. Joint 1 includes angular limits, while Joint 2 uses configurable stiffness and damping. All wall\u2013arm and inter-arm collisions are excluded. A torque-limited motor drives Joint 1, enabling controlled planar manipulation with minimal contact interference.</p> <pre><code>XML = \"\"\"\n&lt;mujoco&gt;\n&lt;option&gt;\n    &lt;flag gravity=\"enable\" contact=\"enable\" /&gt;\n&lt;/option&gt;\n&lt;option timestep=\"{ts}\"/&gt;\n&lt;compiler angle=\"degree\" /&gt;\n&lt;default&gt;\n    &lt;geom contype=\"1\" conaffinity=\"1\" condim=\"3\" friction=\".6 .3 .3\"\n    solimp=\".999 .999 .001\" solref=\".001 1\" margin=\"0.001\" group=\"0\"/&gt;\n&lt;/default&gt;\n\n&lt;worldbody&gt;\n    &lt;light pos=\"0 0 1\"/&gt;\n    &lt;light pos=\"0.1 0.1 1\"/&gt;\n\n    &lt;body name=\"floor\"&gt;\n        &lt;geom type=\"plane\" size=\".5 .5 0.0001\"/&gt;\n    &lt;/body&gt;\n\n\n\n\n    &lt;!-- Box on slider --&gt;\n    &lt;body name=\"trunk\" pos=\"0.035 0 0.025\"&gt;\n        &lt;joint type=\"slide\" axis=\"0 0 1\" damping=\"0.1\" range=\"0 2\"/&gt;\n        &lt;geom type=\"box\" size=\"0.025 0.025 0.025\" pos=\"0 0 0\" rgba=\"1 0.5 0 1\" mass=\"0.01\"/&gt;\n        &lt;camera name=\"trunk_camera\" mode=\"targetbody\" target=\"trunk\" pos=\"0.1 0.4 0.3\"/&gt;\n\n        &lt;!-- First arm - connects to right side of trunk --&gt;\n        &lt;body name=\"link1\" pos=\"0.025 0 -0.025\"&gt;\n            &lt;joint name=\"joint1\" type=\"hinge\" axis=\"0 1 0\" pos=\"0 0 0\" range=\"-1 180\" limited=\"true\"/&gt;\n            &lt;geom type=\"box\" size=\"0.05 0.00625 0.001\" pos=\"0.05 0 0\" rgba=\"0 0.6 1 1\" mass=\"0.002\"/&gt;\n\n            &lt;!-- Second arm - connects to end of first arm --&gt;\n            &lt;body name=\"link2\" pos=\"0.1 0 0\"&gt;\n                &lt;joint name=\"joint2\" type=\"hinge\" axis=\"0 1 0\" pos=\"0 0 0\" stiffness=\"{k}\" damping=\"{b}\"/&gt;\n                &lt;geom type=\"box\" size=\"0.05 0.00625 0.001\" pos=\"0.05 0 0\" rgba=\"1 0 1 1\" mass=\"0.002\"/&gt;\n            &lt;/body&gt;\n        &lt;/body&gt;\n    &lt;/body&gt;\n\n&lt;/worldbody&gt;\n\n&lt;contact&gt;\n    &lt;exclude body1=\"trunk\" body2=\"link1\" /&gt;\n    &lt;exclude body1=\"trunk\" body2=\"link2\" /&gt;\n    &lt;exclude body1=\"link1\" body2=\"link2\" /&gt;\n&lt;/contact&gt;\n\n&lt;actuator&gt;\n    &lt;motor name=\"motor1\" joint=\"joint1\" gear=\"{G}\" ctrllimited=\"true\" ctrlrange=\"-10 10\"/&gt;\n&lt;/actuator&gt;\n&lt;/mujoco&gt;\n\"\"\"\n</code></pre>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#camera-view","title":"Camera view","text":"<pre><code># Display the view\n\nxml_filled = XML.format(ts=ts, k=0, b=0, G=G)\n\nmodel = mujoco.MjModel.from_xml_string(xml_filled)\ndata = mujoco.MjData(model)\n\nmujoco.mj_resetData(model, data)\nmujoco.mj_forward(model, data)\n\nwith mujoco.Renderer(model, 480, 640) as renderer:\n    # t = duration picture\n    renderer.update_scene(data, camera=\"trunk_camera\")\n    print(f\"At t=0s: \")\n    media.show_image(renderer.render())\n</code></pre> <pre><code>At t=0s:\n</code></pre>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#functions-and-simulation","title":"Functions and Simulation","text":""},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#simulation-control-summary","title":"Simulation &amp; Control Summary","text":"<p>I implemented a MuJoCo jumping model defined by an XML file parameterized by timestep <code>ts</code>, gear ratio <code>G</code>, and joint stiffness/damping (<code>k</code>, <code>b</code>). The joint is actuated using a DC motor\u2013based controller, where torque is computed as:</p> <p><code>t = (kt * (V - kv * w * G) / R) * G</code>, with <code>w = data.qvel[1]</code>.</p> <p>The controller is registered via <code>mujoco.set_mjcb_control</code> and writes the torque to <code>data.ctrl</code>.</p> <p>For each stiffness value, <code>simulate_jump(k)</code> builds the model, resets the state, runs the simulation for a fixed duration, and logs trunk position and camera frames. The maximum trunk height is used as the jump performance metric. The <code>find_best_k</code> function sweeps over different <code>k</code> values, calls <code>simulate_jump</code>, and plots jump height vs. stiffness. In the XML, I exclude self-collisions, limit actuator torque using <code>ctrllimited/ctrlrange</code>, and set joint limits and damping for stability and realism.</p> <pre><code># Control the motor torque\ndef mycontroller(model, data):\n    w = data.qvel[1]\n    t = (kt*(V-(kv)*w*G)/R)*G\n    # print(\"w= \", w)\n    # print(\"t= \", t)\n    # print(\"data.time= \", data.time)\n    data.ctrl = [t]\n    return\n\n# Simulate the jump\ndef simulate_jump(k):\n    \"\"\"Simulate jump with given stiffness k\"\"\"\n\n    b = k/100 # damping\n    # print(ts,k,b,G)\n    xml = XML.format(ts=ts, k=k, b=b, G=G)\n    model = mujoco.MjModel.from_xml_string(xml)\n    data = mujoco.MjData(model)\n\n    mujoco.mj_resetData(model, data)\n    mujoco.mj_forward(model, data)\n    # Display initial state\n    renderer = mujoco.Renderer(model)\n    renderer.update_scene(data, camera=\"trunk_camera\")\n    # print(f\"Joint positions at t=0s: \", data.qpos)\n    # print(f\"At t=0s: \")\n    # media.show_image(renderer.render())\n\n    mujoco.set_mjcb_control(mycontroller)\n\n    duration = 5  # (seconds)\n    framerate = 30  # (Hz)\n    data_rate = 100  # Hz - Changed from 10,000 Hz!\n\n    q = []\n    # w_list = []\n    # t_list = []\n    frames = []\n\n    mujoco.mj_resetData(model, data)\n\n    i=0\n    while data.time &lt; duration:\n        i+=1\n        #print(i, data.time, data.ctrl)\n        mujoco.mj_step(model, data)\n\n        if len(frames) &lt; data.time * framerate:\n            renderer.update_scene(data, camera=\"trunk_camera\")\n            pixels = renderer.render()\n            frames.append(pixels)\n\n        if len(q) &lt; data.time * data_rate:\n            q.append(data.qpos.copy())\n            # w_list.append(data.qvel.copy())\n            # t_list.append(data.time)\n\n    mujoco.set_mjcb_control(None)\n\n    q_array = np.array(q)\n    max_height = np.max(q_array[:, 0])  \n    return max_height, frames\n\n# Logarithmic or linear scale searching\ndef find_best_k(kmin=-3, kmax=1, step=100, is_log=True):\n    all_max_heights = {}\n\n    if is_log:\n        for k in np.logspace(kmin, kmax, step):  # logarithmic from 10^kmin to 10^kmax\n            max_height, _ = simulate_jump(k)\n            all_max_heights[k] = max_height\n            # print(f\"k={k:.6f}, Max Height: {max_height:.6f}\")\n    else:\n        for k in np.linspace(kmin, kmax, step):  # linear from kmin to kmax\n            max_height, _ = simulate_jump(k)\n            all_max_heights[k] = max_height\n            # print(f\"k={k:.6f}, Max Height: {max_height:.6f}\")\n\n    # Display results\n    # display(all_max_heights)\n\n    # Plot results\n    ks = list(all_max_heights.keys())\n    heights = list(all_max_heights.values())\n    plt.figure(figsize=(10, 6))\n\n    if is_log:\n        plt.semilogx(ks, heights, 'o-')\n    else:\n        plt.plot(ks, heights, 'o-')  # Use regular plot for linear scale\n\n    plt.xlabel('Stiffness k (N/m)')\n    plt.ylabel('Max Height (m)')\n    plt.title('Jump Height vs Spring Stiffness')\n    plt.grid(True)\n    plt.show()\n\n    return all_max_heights\n</code></pre>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#simulation-video-at-k05","title":"Simulation video at k=0.5","text":"<pre><code>k = 0.0244\nh, frames = simulate_jump(k)\n\nprint(f\"Video at k={k}: \")\nmedia.show_video(frames, fps = frame_rate,codec='gif')\n</code></pre> <pre><code>Video at k=0.0244:\n</code></pre>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#analysis","title":"Analysis","text":""},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#two-stage-stiffness-optimization","title":"Two-stage stiffness optimization","text":"<ol> <li>Coarse sweep (logarithmic) \u2014 evaluate <code>k \u2208 [1e-3, 1e1]</code> with <code>np.logspace(-3,1,30)</code> to cheaply explore orders of magnitude; record peak trunk height from <code>simulate_jump(k)</code> for each sample and plot Height vs. <code>k</code>.</li> <li>Select best candidate \u2014 choose <code>best_k = argmax_k(max_height[k])</code> from the coarse sweep and store its peak <code>best_height</code>.</li> <li>Refined sweep (linear) \u2014 search locally around the candidate using <code>np.linspace(k_min,k_max,20)</code> with <code>k_min = best_k*0.90</code>, <code>k_max = best_k*1.10</code>. Re-evaluate <code>simulate_jump</code> on the finer grid and re-plot to identify the optimal <code>k</code> with higher resolution.</li> <li>Outcome \u2014 report <code>best_k</code> and <code>best_height</code>; use the refined curve to confirm robustness and sensitivity of jump height to stiffness.</li> </ol> <pre><code>print(\"V= \", V)\nprint(\"R= \", R)\nprint(\"kt= \", kt)\nprint(\"kv= \", kv)\n</code></pre> <pre><code>V=  6\nR=  15.0\nkt=  0.0006756756756756756\nkv=  0.005130175\n</code></pre> <p>This gives the best heihgt out of all the k values, right now we are going form k=0.001 to k=10</p> <pre><code># First run to check for best k approximately\nall_max_heights_first = find_best_k(-3, 1, 50, True)\n</code></pre> <p></p> <p>This gives the best height around the k value which was approximately the best, found from previous run. Right now we are going form k_min = best_k * 0.80, and k_max = best_k * 1.20</p> <pre><code># Find the k value with maximum height and then doing a thorough analysis\nbest_k = max(all_max_heights_first, key=all_max_heights_first.get)\nbest_height = all_max_heights_first[best_k]\n\nprint(f\"Best k value: {best_k:.6f}\")\nprint(f\"Maximum height achieved: {best_height:.6f} m\")\n\n# Now do a refined search around the best k\n# Search \u00b150% around best_k with finer resolution\nk_min = best_k * 0.80\nk_max = best_k * 1.20\n\nprint(f\"\\nRefining search from k={k_min:.6f} to k={k_max:.6f}\")\n\nrefined_heights = find_best_k(k_min, k_max, 20, False)\n\n# The best k and height\nbest_k_real = max(refined_heights, key=refined_heights.get)\nbest_height_real = refined_heights[best_k_real]\nprint(\"Best K= \", best_k_real)\nprint(\"Best Height= \", refined_heights)\n</code></pre> <pre><code>Best k value: 0.232995\nMaximum height achieved: 0.301535 m\n\nRefining search from k=0.186396 to k=0.279594\n</code></pre> <p></p> <pre><code>Best K=  0.21582711507931868\nBest Height=  {np.float64(0.18639614484122977): np.float64(0.29862837633754874), np.float64(0.1913013065475779): np.float64(0.29911965125142126), np.float64(0.19620646825392607): np.float64(0.299622054852248), np.float64(0.2011116299602742): np.float64(0.29973750953979855), np.float64(0.20601679166662237): np.float64(0.300204559185998), np.float64(0.2109219533729705): np.float64(0.3007479204712996), np.float64(0.21582711507931868): np.float64(0.3016791213428139), np.float64(0.22073227678566681): np.float64(0.3003153244290619), np.float64(0.22563743849201498): np.float64(0.30091630764034677), np.float64(0.23054260019836312): np.float64(0.30117469512866024), np.float64(0.23544776190471128): np.float64(0.30025266242567733), np.float64(0.24035292361105942): np.float64(0.3009325399658715), np.float64(0.24525808531740756): np.float64(0.3012143067754212), np.float64(0.2501632470237557): np.float64(0.3004965981871866), np.float64(0.2550684087301039): np.float64(0.3007459071497259), np.float64(0.25997357043645203): np.float64(0.30047970406483654), np.float64(0.26487873214280017): np.float64(0.300698983685681), np.float64(0.26978389384914836): np.float64(0.3016160874669507), np.float64(0.2746890555554965): np.float64(0.30047837423094687), np.float64(0.27959421726184464): np.float64(0.30087032658522617)}\n</code></pre>"},{"location":"notebooks/RAS557_Assignment6_1234232638/RAS557_Assignment6_1234232638/#video-of-max-height","title":"Video of max height","text":"<pre><code>h, frames = simulate_jump(best_k_real)\n\nprint(\"Slow motion: \")\nmedia.show_video(frames, fps = frame_rate,codec='gif')\n\nprint(\"\\nSlow motion: \")\nmedia.show_video(frames, fps = 5,codec='gif')\n</code></pre> <pre><code>Slow motion:\n</code></pre> <pre><code>Slow motion:\n</code></pre> <pre><code>import nbformat\nfrom nbconvert import PDFExporter, WebPDFExporter\nfrom traitlets.config import Config\n\nnb_path = \"RAS557_Assignment6_1234232638.ipynb\"\n\n# Prefer webpdf (no LaTeX)\nc = Config()\nc.WebPDFExporter.allow_chromium_download = True\npdf_bytes, _ = WebPDFExporter(config=c).from_filename(nb_path)\n\nwith open(\"RAS557_Assignment6_1234232638.pdf\", \"wb\") as f:\n    f.write(pdf_bytes)\nprint(\"Saved RAS557_Assignment6_1234232638.pdf\")\n</code></pre> <pre><code>Saved RAS557_Assignment6_1234232638.pdf\n</code></pre> <pre><code>\n</code></pre>"},{"location":"notebooks/Sameer_Hopper_File/Sameer_Hopper_File/","title":"Mujoco Model","text":""},{"location":"notebooks/Sameer_Hopper_File/Sameer_Hopper_File/#mujoco-model","title":"Mujoco Model","text":"<pre><code>import mujoco\nimport numpy\nimport math\nimport matplotlib.pyplot as plt\nimport mediapy as media\n</code></pre> <pre><code># Turtle XML template\nturtle_template = \"\"\"\n&lt;mujoco&gt;\n    &lt;option timestep=\"0.001\"&gt;\n        &lt;flag gravity=\"enable\" contact=\"enable\"/&gt;\n    &lt;/option&gt;\n\n    &lt;size nconmax=\"100\" njmax=\"500\"/&gt;\n\n    &lt;default&gt;\n        &lt;geom solimp=\"0.99 0.999 0.001\" solref=\"0.001 1\"/&gt;\n    &lt;/default&gt;\n\n    &lt;compiler angle=\"degree\" /&gt;\n    &lt;visual&gt;&lt;global offwidth=\"{width}\" offheight=\"{height}\" /&gt;&lt;/visual&gt;\n\n    &lt;asset&gt;\n        &lt;texture name=\"floor_tex\" type=\"2d\" builtin=\"checker\" rgb1=\"0.6 0.8 1\" rgb2=\"1 1 1\" width=\"512\" height=\"512\"/&gt;\n        &lt;material name=\"floor_mat\" texture=\"floor_tex\" texrepeat=\"10 10\" reflectance=\"0.3\"/&gt;\n    &lt;/asset&gt;\n\n    &lt;worldbody&gt;\n        &lt;!-- Lighting --&gt;\n        &lt;light name=\"top\" pos=\"1 1 50\"/&gt;\n\n        &lt;!-- Cameras --&gt;\n        &lt;camera name=\"target\" mode=\"targetbody\" target=\"trunk\" pos=\"-0.1 -.15 .08\" axisangle=\"1 0 0 90\" /&gt;\n\n        &lt;body name=\"floor\" pos=\"0 0 0\"&gt;\n            &lt;!-- Checkered floor --&gt;\n            &lt;geom name=\"floor\" type=\"plane\" size=\"5 5 0.1\" rgba=\"0.8 0.9 1 1\" material=\"floor_mat\" pos=\"0 0 -0.0\"/&gt;\n        &lt;/body&gt;\n\n        &lt;body name=\"trunk\" pos=\"0 0 .01\"&gt;\n            &lt;joint type=\"free\"/&gt;\n            &lt;geom type=\"box\" size=\"0.025 0.0175 0.0075\" pos=\"0 0 0\" rgba=\"0 1 0 .5\" mass=\"0.4\"/&gt;\n\n            &lt;body name=\"leg_support1\" pos=\"-.025 0.011 -0.0075\"&gt; \n                &lt;geom type=\"box\" size=\".008 .0065 .001\" pos=\"-.008 0 .001\" rgba=\"0 0 1 1\"/&gt;\n                &lt;geom type=\"box\" size=\".001 .0065 .013\" pos=\"-.016 0 -.013\" rgba=\"0 0 1 1\"/&gt;\n            &lt;/body&gt;\n            &lt;body name=\"leg_support2\" pos=\"-.025 -0.011 -0.0075\"&gt; \n                &lt;geom type=\"box\" size=\".008 .0065 .001\" pos=\"-.008 0 .001\" rgba=\"0 0 1 1\"/&gt;\n                &lt;geom type=\"box\" size=\".001 .0065 .013\" pos=\"-.016 0 -.013\" rgba=\"0 0 1 1\"/&gt;\n            &lt;/body&gt;\n\n            !-- LEG-1 --&gt;\n            &lt;body name=\"leg1_l1\" pos=\".025 -.024 0\"&gt; \n                &lt;geom type=\"box\" size=\".0141 .0065 .001\" pos=\"0 0 0\" rgba=\"0 0 1 1\"/&gt;  &lt;!-- Horizontal first blue link --&gt;\n\n                &lt;!-- LEG-1 Segment 1--&gt;\n                &lt;body name=\"leg1_l2\" pos=\".0141 0 0\"&gt;\n                    &lt;joint name=\"leg1_j2\" type=\"hinge\" axis=\"0 1 0\"\n                    stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                    &lt;geom type=\"box\" size=\".015 .0065 .001\" pos=\"0.015 0 0\" rgba=\"0 1 0 .5\"/&gt;\n                    &lt;geom type=\"box\" size=\".0165 .0065 .001\" pos=\"-0.0165 0 0\" rgba=\"0 0 1 .5\"/&gt;\n                    &lt;body name=\"leg1_l4\" pos=\".03 0 0\"&gt;\n                        &lt;joint name=\"leg1_j3\" type=\"hinge\" axis=\"0 1 0\"\n                        stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                        &lt;geom type=\"box\" size=\".01125 .0065 .001\" pos=\".01125 0 0\" rgba=\"1 0 0 1\"/&gt;\n                    &lt;/body&gt;\n\n                    &lt;!-- Horizontal leg extension --&gt;\n                    &lt;body name=\"leg1_l5\" pos=\"-.033 0 0\" axisangle=\"0 1 0 90\"&gt;\n                        &lt;joint name=\"leg1_j6\" type=\"hinge\" axis=\"0 1 0\"\n                        stiffness=\"0.01\" damping=\"0.001\" limited=\"true\" range=\"0 100\"/&gt;\n                        &lt;geom type=\"box\" size=\".005 .0065 .001\" pos=\".005 0 0\" rgba=\"1 0.6 0 1\"/&gt;\n                    &lt;/body&gt;\n                &lt;/body&gt;\n\n                &lt;!-- LEG-1 Segment 2--&gt;\n                &lt;body name=\"leg1_l3\" pos=\"-.0141 0 0\"&gt;\n                    &lt;joint name=\"leg1_j4\" type=\"hinge\" axis=\"0 1 0\"\n                    stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                    &lt;geom type=\"box\" size=\".0085 .0065 .001\" pos=\"-.0085 0 0\" rgba=\"0 1 0 1\"/&gt;\n                    &lt;body name=\"leg1_l4_2\" pos=\"-.017 0 0\"&gt;\n                        &lt;joint name=\"leg1_j5\" type=\"hinge\" axis=\"0 1 0\"\n                        stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                        &lt;geom type=\"box\" size=\".01125 .0065 .001\" pos=\"-.01125 0 0\" rgba=\".5 .5 .5 1\"/&gt;\n                    &lt;/body&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n\n\n            &lt;!-- LEG-2 --&gt;\n            &lt;body name=\"leg2_l1\" pos=\".025 .024 0\"&gt; \n                &lt;geom type=\"box\" size=\".0141 .0065 .001\" pos=\"0 0 0\" rgba=\"0 0 1 1\"/&gt;\n\n                &lt;!-- LEG-2 Segment 1--&gt;\n                &lt;body name=\"leg2_l2\" pos=\".0141 0 0\"&gt;\n                    &lt;joint name=\"leg2_j2\" type=\"hinge\" axis=\"0 1 0\"\n                    stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                    &lt;geom type=\"box\" size=\".015 .0065 .001\" pos=\"0.015 0 0\" rgba=\"0 1 0 .5\"/&gt;\n                    &lt;geom type=\"box\" size=\".0165 .0065 .001\" pos=\"-0.0165 0 0\" rgba=\"0 0 1 .5\"/&gt;\n\n                    &lt;body name=\"leg2_l4\" pos=\".03 0 0\"&gt;\n                        &lt;joint name=\"leg2_j3\" type=\"hinge\" axis=\"0 1 0\"\n                        stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                        &lt;geom type=\"box\" size=\".01125 .0065 .001\" pos=\".01125 0 0\" rgba=\"1 0 0 1\"/&gt;\n                    &lt;/body&gt;\n\n                    &lt;!-- Horizontal leg extension --&gt;\n                    &lt;body name=\"leg2_l5\" pos=\"-.033 0 0\" axisangle=\"0 1 0 90\"&gt;\n                        &lt;joint name=\"leg2_j6\" type=\"hinge\" axis=\"0 1 0\"\n                        stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"0 100\"/&gt;\n                        &lt;geom type=\"box\" size=\".005 .0065 .001\" pos=\".005 0 0\" rgba=\"1 0.6 0 1\"/&gt;\n                    &lt;/body&gt;\n                &lt;/body&gt;\n\n                &lt;!-- LEG-2 Segment 2--&gt;\n                &lt;body name=\"leg2_l3\" pos=\"-.0141 0 0\"&gt;\n                    &lt;joint name=\"leg2_j4\" type=\"hinge\" axis=\"0 1 0\"\n                    stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                    &lt;geom type=\"box\" size=\".0085 .0065 .001\" pos=\"-.0085 0 0\" rgba=\"0 1 0 1\"/&gt;\n                    &lt;body name=\"leg2_l4_2\" pos=\"-.017 0 0\"&gt;\n                        &lt;joint name=\"leg2_j5\" type=\"hinge\" axis=\"0 1 0\"\n                        stiffness=\"{k:e}\" damping=\"{b:e}\" limited=\"true\" range=\"-179 179\"/&gt;\n                        &lt;geom type=\"box\" size=\".01125 .0065 .001\" pos=\"-.01125 0 0\" rgba=\".5 .5 .5 1\"/&gt;\n                    &lt;/body&gt;\n                &lt;/body&gt;\n            &lt;/body&gt;\n\n        &lt;/body&gt;\n    &lt;/worldbody&gt;\n\n    &lt;contact&gt;\n        &lt;!-- Exclude consecutive links in leg1 --&gt;\n        &lt;exclude body1=\"leg1_l1\" body2=\"leg1_l2\"/&gt;\n        &lt;exclude body1=\"leg1_l1\" body2=\"leg1_l3\"/&gt;\n        &lt;exclude body1=\"leg1_l2\" body2=\"leg1_l4\"/&gt;\n        &lt;exclude body1=\"leg1_l2\" body2=\"leg1_l5\"/&gt;\n        &lt;exclude body1=\"leg1_l3\" body2=\"leg1_l4_2\"/&gt;\n\n        &lt;!-- Exclude consecutive links in leg2 --&gt;\n        &lt;exclude body1=\"leg2_l1\" body2=\"leg2_l2\"/&gt;\n        &lt;exclude body1=\"leg2_l1\" body2=\"leg2_l3\"/&gt;\n        &lt;exclude body1=\"leg2_l2\" body2=\"leg2_l4\"/&gt;\n        &lt;exclude body1=\"leg2_l2\" body2=\"leg2_l5\"/&gt;\n        &lt;exclude body1=\"leg2_l3\" body2=\"leg2_l4_2\"/&gt;\n    &lt;/contact&gt;\n\n    &lt;actuator&gt;\n        &lt;position name=\"mR\" joint=\"leg1_j4\"/&gt;\n        &lt;position name=\"mL\" joint=\"leg2_j4\"/&gt;\n    &lt;/actuator&gt;\n\n    &lt;equality&gt;\n        &lt;weld name=\"weld1\" active=\"true\" body1=\"leg1_l4\" body2=\"leg1_l4_2\"\n        anchor=\"-.0225 0 0\" relpose=\".0225 0 0 1 0 0 0\" solimp=\".90 .99 .01\" solref=\".001 1\"/&gt;\n        &lt;weld name=\"weld2\" active=\"true\" body1=\"leg2_l4\" body2=\"leg2_l4_2\"\n        anchor=\"-.0225 0 0\" relpose=\".0225 0 0 1 0 0 0\" solimp=\".90 .99 .01\" solref=\".001 1\"/&gt;\n    &lt;/equality&gt;\n&lt;/mujoco&gt;\n\"\"\"\n</code></pre> <pre><code># Simulation parameters\nwidth = 640\nheight = 480\nduration = 10  # seconds\nframerate = 120  # Hz\n\n# Turtle gait parameters\namplitude = 30 * math.pi / 180  # Leg swing amplitude in radians\nfrequency = 1 # Gait frequency in Hz\nphase_offset = 0.25  # Phase difference between legs (0.25 = 90 degrees out of phase)\nleg_bias = 60 * math.pi / 180  # Baseline leg angle (negative = legs pointing backward)\n\n\ndef gen_controller(frequency, amplitude, phase_offset, leg_bias):\n    \"\"\"Generate controller function for turtle locomotion\"\"\"\n\n    # We need to track accumulated phase\n    phase_state = {'right_phase': 0, 'left_phase': 0, 'last_t': 0}\n\n    def my_controller(model, data):\n        t = data.time\n\n        # Calculate dt\n        if phase_state['last_t'] == 0:\n            dt = 0.001  # First timestep\n        else:\n            dt = t - phase_state['last_t']\n        phase_state['last_t'] = t\n\n        # Gradually ramp up leg movement from 0 to full amplitude over first 2 seconds\n        if t &lt; 1:\n            current_amplitude = 0\n        else:\n            current_amplitude = amplitude\n\n        # Get current angles in cycle (0 to 2\u03c0)\n        right_angle = phase_state['right_phase'] % (2 * math.pi)\n        left_angle = phase_state['left_phase'] % (2 * math.pi)\n\n        # Determine speed multiplier based on angle position\n        # Fast in 1st and 4th quarters (0-90\u00b0 and 270-360\u00b0)\n        # Normal in 2nd and 3rd quarters (90-270\u00b0)\n\n        # Right leg speed\n        if right_angle &lt; math.pi/2 or right_angle &gt; 3*math.pi/2:\n            right_speed = 4.0  # Double speed\n        else:\n            right_speed = 0.5  # Normal speed\n\n        # Left leg speed\n        if left_angle &lt; math.pi/2 or left_angle &gt; 3*math.pi/2:\n            left_speed = 0.5  # Double speed\n        else:\n            left_speed = 4.0  # Normal speed\n\n        # Update phases with variable speed\n        phase_state['right_phase'] += right_speed * 2 * math.pi * frequency * dt\n        phase_state['left_phase'] += left_speed * 2 * math.pi * frequency * dt\n\n        # Calculate leg angles from accumulated phase\n        right_leg_angle = current_amplitude * math.sin(phase_state['right_phase'] - 2 * math.pi * frequency * phase_offset) + leg_bias\n        left_leg_angle = current_amplitude * math.sin(phase_state['left_phase']) + leg_bias\n\n        # Apply control\n        data.ctrl = [right_leg_angle, left_leg_angle]\n\n    return my_controller\n\n\ndef run_sim(model, data, qpos, my_controller, show_video=True):\n    \"\"\"Run MuJoCo simulation and capture frames\"\"\"\n    # CREATE NEW RENDERER each time\n    renderer = mujoco.Renderer(model, width=width, height=height)\n\n    mujoco.set_mjcb_control(my_controller)\n    frames = []\n\n    # Data collection for trunk\n    trunk_data = {\n        'time': [],\n        'pos_x': [],\n        'pos_y': [],\n        'pos_z': [],\n        'vel_x': [],\n        'vel_y': [],\n        'vel_z': []\n    }\n\n    mujoco.mj_resetData(model, data)\n    data.qpos = qpos\n    i = 1\n\n    # Get trunk body ID\n    trunk_id = mujoco.mj_name2id(model, mujoco.mjtObj.mjOBJ_BODY, 'trunk')\n\n    while data.time &lt; duration:\n        mujoco.mj_step(model, data)\n\n        # Collect trunk position and velocity\n        trunk_data['time'].append(data.time)\n        trunk_data['pos_x'].append(data.xpos[trunk_id][0])\n        trunk_data['pos_y'].append(data.xpos[trunk_id][1])\n        trunk_data['pos_z'].append(data.xpos[trunk_id][2])\n        trunk_data['vel_x'].append(data.cvel[trunk_id][3])  # Linear velocity\n        trunk_data['vel_y'].append(data.cvel[trunk_id][4])\n        trunk_data['vel_z'].append(data.cvel[trunk_id][5])\n\n        if len(frames) &lt; data.time * framerate:\n            renderer.update_scene(data, camera='target')\n            pixels = renderer.render()\n            frames.append(pixels)\n            if i == 1:\n                media.show_image(pixels)\n                i += 1\n\n    mujoco.set_mjcb_control(None)\n\n    # Close renderer after use\n    renderer.close()\n\n    # Save trunk data to CSV\n    import pandas as pd\n    df = pd.DataFrame(trunk_data)\n    df.to_csv('trunk_data.csv', index=False)\n    print(f\"Trunk data saved to 'trunk_data.csv' ({len(df)} timesteps)\")\n\n    if show_video:\n        media.show_video(frames, fps=framerate, width=width, height=height)\n\n    return frames, trunk_data\n</code></pre> <pre><code># Initialize model\nxml = turtle_template.format(width=width, height=height, k=1e-5, b=1e-6)\nmodel = mujoco.MjModel.from_xml_string(xml)\ndata = mujoco.MjData(model)\nrenderer = mujoco.Renderer(model, width=width, height=height)\n\n# Set initial pose\nzero_rotation = numpy.array([1, 0, 0, 0])\nqpos1 = numpy.array([0, 0, 0.05])\nqpos2 = numpy.array([-80, -110, 0, 60, 90]) * math.pi / 180 #value at the 4th place is for the new joint \nqpos3 = numpy.array([-80, -110, 0, 60, 90]) * math.pi / 180 #value at the 4th place is for the new joint \nqpos = numpy.hstack([qpos1, zero_rotation, qpos2, qpos3])\n\n# Generate controller and run simulation\nmy_controller = gen_controller(frequency, amplitude, phase_offset, leg_bias)\nframes, trunk_data = run_sim(model, data, qpos, my_controller, False)\n\n# Display final frame\nplt.imshow(frames[-1])\nplt.axis('off')\nplt.show()\n\n# Show animation\nmedia.show_video(frames, fps=framerate)\n</code></pre> <pre><code>Trunk data saved to 'trunk_data.csv' (10001 timesteps)\n</code></pre>        This browser does not support the video tag.        <pre><code>fig, axes = plt.subplots(2, 3, figsize=(15, 8))\n\n# Position plots\naxes[0, 0].plot(trunk_data['time'], trunk_data['pos_x'])\naxes[0, 0].set_title('Trunk X Position')\naxes[0, 0].set_xlabel('Time (s)')\naxes[0, 0].set_ylabel('Position (m)')\naxes[0, 0].grid(True)\n\naxes[0, 1].plot(trunk_data['time'], trunk_data['pos_y'])\naxes[0, 1].set_title('Trunk Y Position')\naxes[0, 1].set_xlabel('Time (s)')\naxes[0, 1].set_ylabel('Position (m)')\naxes[0, 1].grid(True)\n\naxes[0, 2].plot(trunk_data['time'], trunk_data['pos_z'])\naxes[0, 2].set_title('Trunk Z Position')\naxes[0, 2].set_xlabel('Time (s)')\naxes[0, 2].set_ylabel('Position (m)')\naxes[0, 2].grid(True)\n\n# Velocity plots\naxes[1, 0].plot(trunk_data['time'], trunk_data['vel_x'])\naxes[1, 0].set_title('Trunk X Velocity')\naxes[1, 0].set_xlabel('Time (s)')\naxes[1, 0].set_ylabel('Velocity (m/s)')\naxes[1, 0].grid(True)\n\naxes[1, 1].plot(trunk_data['time'], trunk_data['vel_y'])\naxes[1, 1].set_title('Trunk Y Velocity')\naxes[1, 1].set_xlabel('Time (s)')\naxes[1, 1].set_ylabel('Velocity (m/s)')\naxes[1, 1].grid(True)\n\naxes[1, 2].plot(trunk_data['time'], trunk_data['vel_z'])\naxes[1, 2].set_title('Trunk Z Velocity')\naxes[1, 2].set_xlabel('Time (s)')\naxes[1, 2].set_ylabel('Velocity (m/s)')\naxes[1, 2].grid(True)\n\nplt.tight_layout()\nplt.show()\n</code></pre> <pre><code># Print everything in qpos with labels\nprint(\"qpos (Generalized Positions):\")\n\n# Free joint (trunk) - first 7 values\nprint(\"\\nTrunk (Free Joint):\")\nprint(f\"  Position X:     {data.qpos[0]:.6f}\")\nprint(f\"  Position Y:     {data.qpos[1]:.6f}\")\nprint(f\"  Position Z:     {data.qpos[2]:.6f}\")\nprint(f\"  Quaternion W:   {data.qpos[3]:.6f}\")\nprint(f\"  Quaternion X:   {data.qpos[4]:.6f}\")\nprint(f\"  Quaternion Y:   {data.qpos[5]:.6f}\")\nprint(f\"  Quaternion Z:   {data.qpos[6]:.6f}\")\n\n# Joint angles - remaining values\nprint(\"\\nJoint Angles (radians):\")\njoint_start_idx = 7  # Joints start after the free joint (7 DOF)\nfor i in range(model.njnt):\n    if model.joint(i).type[0] != 0:  # Skip free joint (already printed)\n        joint_name = model.joint(i).name\n        qpos_idx = joint_start_idx\n        angle_deg = data.qpos[qpos_idx] * 180 / math.pi\n        print(f\"  [{qpos_idx:2d}] {joint_name:15s}: {data.qpos[qpos_idx]:8.4f} rad ({angle_deg:7.2f}\u00b0)\")\n        joint_start_idx += 1\n\n# Print total\nprint(f\"\\nTotal qpos size: {model.nq}\")\nprint(f\"Full qpos array:\\n{data.qpos}\")\n</code></pre> <pre><code>qpos (Generalized Positions):\n\nTrunk (Free Joint):\n  Position X:     -0.050003\n  Position Y:     -0.024914\n  Position Z:     0.033302\n  Quaternion W:   0.925145\n  Quaternion X:   -0.000650\n  Quaternion Y:   0.002558\n  Quaternion Z:   0.379604\n\nJoint Angles (radians):\n  [ 7] leg1_j2        :  -1.3009 rad ( -74.53\u00b0)\n  [ 8] leg1_j3        :  -2.1423 rad (-122.75\u00b0)\n  [ 9] leg1_j6        :  -0.2239 rad ( -12.83\u00b0)\n  [10] leg1_j4        :   1.1481 rad (  65.78\u00b0)\n  [11] leg1_j5        :   1.6928 rad (  96.99\u00b0)\n  [12] leg2_j2        :  -1.5006 rad ( -85.98\u00b0)\n  [13] leg2_j3        :  -2.0335 rad (-116.51\u00b0)\n  [14] leg2_j6        :  -1.4004 rad ( -80.24\u00b0)\n  [15] leg2_j4        :   0.8461 rad (  48.48\u00b0)\n  [16] leg2_j5        :   1.9035 rad ( 109.06\u00b0)\n\nTotal qpos size: 17\nFull qpos array:\n[-5.00029135e-02 -2.49140253e-02  3.33022219e-02  9.25145310e-01\n -6.49925358e-04  2.55794535e-03  3.79603991e-01 -1.30085497e+00\n -2.14233212e+00 -2.23890419e-01  1.14807561e+00  1.69278308e+00\n -1.50061120e+00 -2.03348547e+00 -1.40040082e+00  8.46113826e-01\n  1.90349143e+00]\n</code></pre>"},{"location":"notebooks/grass_body/grass_body/","title":"Trunk","text":"<p>pip install foldable_robotics</p> <pre><code>pip install pycairo\n</code></pre> <pre><code>Requirement already satisfied: pycairo in c:\\users\\shawn\\anaconda3\\envs\\mujoco\\lib\\site-packages (1.28.0)\nNote: you may need to restart the kernel to use updated packages.\n</code></pre> <pre><code>import foldable_robotics.dxf as frd\nimport foldable_robotics as fr\nimport foldable_robotics.manufacturing as frm\nfrom foldable_robotics.layer import Layer\nfrom foldable_robotics.laminate import Laminate\nimport foldable_robotics.parts.castellated_hinge2 as frc\nimport shapely.geometry as sg\nfr.display_height=300\n</code></pre> <pre><code>fr.resolution = 4\n</code></pre> <pre><code>desired_degrees = 120\nthickness = 1\nplain_width = frm.plain_hinge_width(desired_degrees,thickness)\nplain_width\n</code></pre> <pre><code>1.7320508075688774\n</code></pre> <pre><code>support_width = 2 # must be larger than hinge width\nkerf = .05\nis_adhesive = [False,True,False,True,False]\narc_approx = 10\nNUM_LAYERS = 5\nbridge_thickness = 1\nbounding_box_padding = 10\njig_spacing = 10\njig_dia = 5\nbody_vertices = frd.read_lwpolylines('grass_body.dxf',\nlayer='body',\narc_approx = arc_approx)\nbody_vertices\n</code></pre> <pre><code>[[[4.766956363928312, 54.93657673278085],\n  [194.7669563639283, 54.93657673278085],\n  [194.7669563639283, 89.93657673278085],\n  [4.766956363928314, 89.93657673278085],\n  [4.766956363928312, 54.93657673278085]]]\n</code></pre> <pre><code>body_polygons = [sg.Polygon(item) for item in body_vertices]\nbody_polygons[0]\n</code></pre> <p></p> <pre><code>body_layer = Layer(*body_polygons)\nbody_layer\n</code></pre> <p></p> <pre><code>hole_vertices = frd.read_lwpolylines('grass_body.dxf',\nlayer='holes',\narc_approx = arc_approx)\nhole_layer = Layer(*[sg.Polygon(item) for item in hole_vertices])\nhole_layer\n</code></pre> <p></p> <pre><code>body_layer -= hole_layer\nbody_layer\n</code></pre> <p></p> <pre><code>cut_vertices = frd.read_lwpolylines('grass_body.dxf',\nlayer='cuts',\narc_approx = arc_approx)\ncut_layer = Layer(*[sg.LineString(item) for item in cut_vertices])\ncut_layer\ncut_layer &lt;&lt;=.5\ncut_layer\nbody_layer -= cut_layer\nbody_layer\n</code></pre> <p></p> <pre><code>joint_vertices = frd.read_lines('grass_body.dxf', layer='joints')\njoint_vertices\n</code></pre> <pre><code>[[[23.76695636392832, 89.93657673278085],\n  [23.76695636392832, 54.93657673278085]],\n [[47.76695636392832, 89.93657673278085],\n  [47.76695636392832, 54.93657673278085]],\n [[61.76695636392832, 89.93657673278085],\n  [61.76695636392832, 54.93657673278085]],\n [[101.7669563639283, 89.93657673278085],\n  [101.7669563639283, 54.93657673278085]],\n [[165.7669563639283, 89.93657673278085],\n  [165.7669563639283, 54.93657673278085]],\n [[179.7669563639283, 89.93657673278085],\n  [179.7669563639283, 54.93657673278085]],\n [[189.7669563639283, 89.93657673278085],\n  [189.7669563639283, 54.93657673278085]],\n [[115.7669563639283, 89.93657673278085],\n  [115.7669563639283, 54.93657673278085]],\n [[9.76696, 89.9366], [9.76696, 54.9366]]]\n</code></pre> <pre><code>l = sg.LineString(joint_vertices[0])\nl\n</code></pre> <p></p> <pre><code>joint_lines_original_layer = Layer(*[sg.LineString(item) for item in joint_vertices])\njoint_lines_original_layer\n</code></pre> <p></p> <pre><code>body_layer.plot()\njoint_lines_original_layer.plot()\n</code></pre> <p></p> <pre><code>joint_lines_modified_layer = joint_lines_original_layer &amp; body_layer\nbody_layer.plot()\njoint_lines_modified_layer.plot()\n</code></pre> <p></p> <pre><code>modified_joint_vertices = [list(item.coords) for item in joint_lines_modified_layer.geoms]\nmodified_joint_vertices\n</code></pre> <pre><code>[[(23.76695636392832, 89.93657673278085),\n  (23.76695636392832, 54.93657673278085)],\n [(47.76695636392832, 89.93657673278085),\n  (47.76695636392832, 54.93657673278085)],\n [(61.76695636392832, 89.93657673278085),\n  (61.76695636392832, 54.93657673278085)],\n [(101.7669563639283, 89.93657673278085),\n  (101.7669563639283, 54.93657673278085)],\n [(165.7669563639283, 89.93657673278085),\n  (165.7669563639283, 54.93657673278085)],\n [(179.7669563639283, 89.93657673278085),\n  (179.7669563639283, 54.93657673278085)],\n [(189.7669563639283, 89.93657673278085),\n  (189.7669563639283, 54.93657673278085)],\n [(115.7669563639283, 89.93657673278085),\n  (115.7669563639283, 54.93657673278085)],\n [(9.76696, 89.93657673278085), (9.76696, 54.9366)]]\n</code></pre> <pre><code>simple_joint_layer = joint_lines_modified_layer &lt;&lt; plain_width/2\nsimple_joint_layer\n</code></pre> <p></p> <pre><code>hole,dummy = frm.calc_hole(modified_joint_vertices,plain_width/2)\nfr.my_line_width=0\nholes = hole.to_laminate(NUM_LAYERS)\nholes&lt;&lt;=.5 # add a little extra material to ensure we removed enough.\nholes\n</code></pre> <p></p> <pre><code>&lt;Figure size 640x480 with 0 Axes&gt;\n</code></pre> <pre><code>rigid_layer = (body_layer - simple_joint_layer)\nrigid_layer\n</code></pre> <p></p> <pre><code>adhesive_layer = rigid_layer &amp; body_layer\nadhesive_layer\n</code></pre> <p></p> <pre><code>ideal_final_device = Laminate(rigid_layer,adhesive_layer, body_layer,\nadhesive_layer,rigid_layer)\nideal_final_device\n</code></pre> <p></p> <pre><code>ideal_final_device[0]\n</code></pre> <p></p> <pre><code>ideal_final_device[2]\n</code></pre> <p></p> <pre><code>bridges = frd.read_lines('grass_body.dxf', layer='bridge')\nbridges\nbridges_layer = Layer(*[sg.LineString(item) for item in bridges])\nbridges_layer &lt;&lt;= bridge_thickness\nbridges_layer\n</code></pre> <p></p> <pre><code>bridges_lam = Laminate(bridges_layer,bridges_layer,Layer(),bridges_layer,bridges_layer)\nbridges_lam\n</code></pre> <p></p> <pre><code>supported_actual_device = ideal_final_device | bridges_lam\nsupported_actual_device\n</code></pre> <p></p> <pre><code>diff = supported_actual_device - ideal_final_device\nremoval = frm.cleanup(diff, .1)\nremoval\n</code></pre> <p></p> <pre><code>removal = frm.keepout_laser(removal)\nremoval\n</code></pre> <p></p> <pre><code>actual_final_device = ideal_final_device- holes - removal\nactual_final_device\n</code></pre> <p></p> <pre><code>keepout = frm.keepout_laser(actual_final_device)\nkeepout\n</code></pre> <p></p> <pre><code>layer_id = frm.build_layer_numbers(NUM_LAYERS,\ntext_size=jig_dia)\nlayer_id = layer_id.simplify(.2)\nlayer_id[0]\n</code></pre> <p></p> <pre><code>(x1,y1),(x2,y2) = actual_final_device.bounding_box_coords()\nw1,h1 = actual_final_device.get_dimensions()\nw2 = round(w1/jig_spacing)*jig_spacing+jig_spacing+support_width\nh2 = round(h1/jig_spacing)*jig_spacing+jig_spacing+support_width\nx1 -= (w2-w1)/2\ny1 -= (h2-h1)/2\nx2 += (w2-w1)/2\ny2 += (h2-h1)/2\npoints = []\npoints.append(sg.Point(x1,y1))\npoints.append(sg.Point(x2,y1))\npoints.append(sg.Point(x1,y2))\npoints.append(sg.Point(x2,y2))\nalignment_holes_layer = Layer(*points)\nalignment_holes_layer&lt;&lt;=(jig_dia/2)\nalignment_holes=alignment_holes_layer.to_laminate(NUM_LAYERS)\nalignment_holes\n</code></pre> <p></p> <pre><code>sheet_layer = (alignment_holes_layer&lt;&lt;bounding_box_padding).bounding_box()\nsheet=sheet_layer.to_laminate(NUM_LAYERS)\nsheet\n</code></pre> <p></p> <pre><code>removable_scrap = frm.calculate_removable_scrap(\nactual_final_device,sheet,support_width,is_adhesive)\nweb = removable_scrap-alignment_holes-layer_id.translate(x1+jig_dia,y1-jig_dia/2)\nweb\n</code></pre> <p></p> <pre><code>(web|actual_final_device)\n</code></pre> <p></p> <pre><code>second_pass_scrap = sheet-keepout\nsecond_pass_scrap\n</code></pre> <p></p> <pre><code>first_pass_scrap = sheet - second_pass_scrap - actual_final_device\nfirst_pass_scrap = frm.cleanup(first_pass_scrap,.00001)\nfirst_pass_scrap\n</code></pre> <p></p> <pre><code>support = frm.support(actual_final_device,\nfrm.keepout_laser,support_width,support_width/2)\nsupport\n</code></pre> <p></p> <pre><code>support | bridges_lam\n</code></pre> <p></p> <pre><code>supported_design = web|actual_final_device|support| bridges_lam\nsupported_design\n</code></pre> <p></p> <pre><code>cut_material = (keepout&lt;&lt;kerf)-keepout\ncut_material\n</code></pre> <p></p> <pre><code>remaining_material = supported_design-cut_material\nremaining_material\n</code></pre> <p></p> <pre><code>remaining_parts = frm.find_connected(remaining_material,is_adhesive)\nfor item in remaining_parts:\n    item.plot(new=True)\n</code></pre> <p></p> <p></p> <p></p> <p></p> <p></p> <p></p> <pre><code>test_part=actual_final_device&gt;&gt;1\nfor result in remaining_parts:\n    if not (result&amp;test_part).is_null():\n        break\nresult\n</code></pre> <p></p> <pre><code>check = (result^actual_final_device)\ncheck&gt;&gt;=1e-1\nassert(check.is_null())\n</code></pre> <pre><code>w,h = supported_design.get_dimensions()\np0,p1 = supported_design.bounding_box_coords()\nrigid_layer = supported_design[0] | (supported_design[-1].translate(w+5,0))\nrigid_layer\n</code></pre> <p></p> <pre><code>l4 = supported_design[3].scale(-1,1)\np2,p3 = l4.bounding_box_coords()\nl4 = l4.translate(p0[0]-p2[0]+w+5,p0[1]-p2[1])\nadhesive_layer = supported_design[1] | l4\nadhesive_layer\n</code></pre> <p></p> <pre><code>first_pass = Laminate(rigid_layer,adhesive_layer,supported_design[2])\nfirst_pass.export_dxf('first_pass_body')\n</code></pre> <pre><code>final_cut = sheet - keepout\nfinal_cut = final_cut[0]\nfinal_cut.export_dxf('final_cut_body')\nfinal_cut\n</code></pre> <p></p> <pre><code>from foldable_robotics.pdf import Page\nimport foldable_robotics.pdf as frp\n</code></pre> <pre><code># === 2-row grid with mirrored pairs + final_cut in top-right ===\n# Configure which laminate layers to use\nTOP_IDX = 4        # &lt;- pick the \"different\" layer number for the NEW TOP row\nBOTTOM_IDX = 3     # &lt;- your current layer number for the BOTTOM row\n\nS = frp.ppi / 25.4     # mm -&gt; PDF points\nPAD = 30               # page margins (pt)\nGAP_X, GAP_Y = 60, 80  # spacing between cells (pt)\nCELL_PAD = 12          # inner padding in each cell (pt)\n\ndef as_layer(obj):\n    # Accept a Layer or Laminate; return a Layer (first layer if Laminate) \n    return obj if hasattr(obj, \"get_paths\") else obj.layers[0]\n\ndef normalize(layer):\n    # Scale to points and move bottom-left to (0,0)\n    L = layer.scale(S, S)\n    (x0, y0), _ = L.bounding_box_coords()\n    return L.translate(-x0, -y0)\n\ndef mirror_h(layer):\n    # Mirror horizontally about the layer's own center\n    (a, b) = layer.bounding_box_coords()\n    cx = (a[0] + b[0]) / 2\n    return layer.translate(-cx, 0).scale(-1, 1).translate(cx, 0)\n\ndef size(layer):\n    (a, b) = layer.bounding_box_coords()\n    return (b[0] - a[0], b[1] - a[1])\n\ndef scale_to_fit(layer, w, h, pad=CELL_PAD):\n    lw, lh = size(layer)\n    if lw == 0 or lh == 0: \n        return layer\n    k = min((w - pad)/lw, (h - pad)/lh, 1.0)\n    return layer.scale(k, k)\n\ndef draw(page, obj):\n    # Draw a Layer or Laminate\n    layers = getattr(obj, \"layers\", [obj])\n    for lyr in layers:\n        for path in lyr.get_paths():\n            page.draw_poly(path)\n\n# --- build the six cells (2 rows \u00d7 3 cols) ---\n# top row: [ left_pair(original @ TOP_IDX), mirrored(TOP_IDX), final_cut ]\n# bottom row: [ left_pair(original @ BOTTOM_IDX), mirrored(BOTTOM_IDX), (empty) ]\n\ntop_left  = normalize(as_layer(supported_design[TOP_IDX]))\ntop_right = mirror_h(top_left)\n\nbot_left  = normalize(as_layer(supported_design[BOTTOM_IDX]))\nbot_right = mirror_h(bot_left)\n\nfinal_layer = normalize(as_layer(final_cut))   # final_cut already a Layer in your notebook\n\n# Estimate a reasonable cell size from the largest item\nmax_w = max(size(L)[0] for L in [top_left, top_right, bot_left, bot_right, final_layer])\nmax_h = max(size(L)[1] for L in [top_left, top_right, bot_left, bot_right, final_layer])\nCELL_W = max_w + 80\nCELL_H = max_h + 80\n\n# Page size (2 rows \u00d7 3 cols)\npage_w = PAD + 3*CELL_W + 2*GAP_X + PAD\npage_h = PAD + 2*CELL_H + GAP_Y + PAD\n\np = Page('grass_plus__body_final.pdf', height=page_h)\n\ndef place(layer, row, col):\n    # fit to cell and center within that cell\n    Lf = scale_to_fit(layer, CELL_W, CELL_H)\n    (a, b) = Lf.bounding_box_coords()\n    lw, lh = size(Lf)\n    x0 = PAD + col*(CELL_W + GAP_X)\n    y0 = page_h - PAD - (row+1)*CELL_H - row*GAP_Y  # rows from top\n    dx = x0 + (CELL_W - lw)/2 - a[0]\n    dy = y0 + (CELL_H - lh)/2 - a[1]\n    draw(p, Lf.translate(dx, dy))\n\n# Top row (row 0)\nplace(top_left,  0, 0)\nplace(top_right, 0, 1)\nplace(final_layer, 0, 2)\n\n# Bottom row (row 1)\nplace(bot_left,  1, 0)\nplace(bot_right, 1, 1)\n# leave (row 1, col 2) empty, or duplicate final_layer there if you like:\n# place(final_layer, 1, 2)\n\np.close()\nprint(\"\u2705 Exported: grass_two_rows_plus_final.pdf\")\n</code></pre> <pre><code>\u2705 Exported: grass_two_rows_plus_final.pdf\n</code></pre>"},{"location":"notebooks/grass_manu/grass_manu/","title":"Hind Legs","text":"<p>pip install foldable_robotics</p> <pre><code>pip install pycairo\n</code></pre> <pre><code>Requirement already satisfied: pycairo in c:\\users\\shawn\\anaconda3\\envs\\mujoco\\lib\\site-packages (1.28.0)\nNote: you may need to restart the kernel to use updated packages.\n</code></pre> <pre><code>import foldable_robotics.dxf as frd\nimport foldable_robotics as fr\nimport foldable_robotics.manufacturing as frm\nfrom foldable_robotics.layer import Layer\nfrom foldable_robotics.laminate import Laminate\nimport foldable_robotics.parts.castellated_hinge2 as frc\nimport shapely.geometry as sg\nfr.display_height=300\n</code></pre> <pre><code>fr.resolution = 4\n</code></pre> <pre><code>desired_degrees = 120\nthickness = 1\nplain_width = frm.plain_hinge_width(desired_degrees,thickness)\nplain_width\n</code></pre> <pre><code>1.7320508075688774\n</code></pre> <pre><code>support_width = 2 # must be larger than hinge width\nkerf = .05\nis_adhesive = [False,True,False,True,False]\narc_approx = 10\nNUM_LAYERS = 5\nbridge_thickness = 1\nbounding_box_padding = 10\njig_spacing = 10\njig_dia = 5\nbody_vertices = frd.read_lwpolylines('grass_bar.dxf',\nlayer='body',\narc_approx = arc_approx)\nbody_vertices\n</code></pre> <pre><code>[[[1.56136, 70.7607],\n  [173.761, 70.7607],\n  [173.761, 51.1607],\n  [1.56136, 51.1607]]]\n</code></pre> <pre><code>body_polygons = [sg.Polygon(item) for item in body_vertices]\nbody_polygons[0]\n</code></pre> <p></p> <pre><code>body_layer = Layer(*body_polygons)\nbody_layer\n</code></pre> <p></p> <pre><code>hole_vertices = frd.read_lwpolylines('grass_bar.dxf',\nlayer='holes',\narc_approx = arc_approx)\nhole_layer = Layer(*[sg.Polygon(item) for item in hole_vertices])\nhole_layer\n</code></pre> <p></p> <pre><code>body_layer -= hole_layer\nbody_layer\n</code></pre> <p></p> <pre><code>cut_vertices = frd.read_lwpolylines('grass_bar.dxf',\nlayer='cuts',\narc_approx = arc_approx)\ncut_layer = Layer(*[sg.LineString(item) for item in cut_vertices])\ncut_layer\ncut_layer &lt;&lt;=.5\ncut_layer\nbody_layer -= cut_layer\nbody_layer\n</code></pre> <p></p> <pre><code>joint_vertices = frd.read_lines('grass_bar.dxf', layer='joints')\njoint_vertices\n</code></pre> <pre><code>[[[6.561360419843481, 70.76067563916963],\n  [6.561360419843481, 51.16067563916963]],\n [[35.76136041984348, 70.76067563916963],\n  [35.76136041984348, 51.16067563916964]],\n [[52.76136041984348, 70.76067563916963],\n  [52.76136041984348, 51.16067563916963]],\n [[97.76136041984348, 70.76067563916963],\n  [97.76136041984348, 51.16067563916963]],\n [[160.7613604198435, 70.76067563916963],\n  [160.7613604198435, 51.16067563916963]]]\n</code></pre> <pre><code>l = sg.LineString(joint_vertices[0])\nl\n</code></pre> <p></p> <pre><code>joint_lines_original_layer = Layer(*[sg.LineString(item) for item in joint_vertices])\njoint_lines_original_layer\n</code></pre> <p></p> <pre><code>body_layer.plot()\njoint_lines_original_layer.plot()\n</code></pre> <p></p> <pre><code>joint_lines_modified_layer = joint_lines_original_layer &amp; body_layer\nbody_layer.plot()\njoint_lines_modified_layer.plot()\n</code></pre> <p></p> <pre><code>modified_joint_vertices = [list(item.coords) for item in joint_lines_modified_layer.geoms]\nmodified_joint_vertices\n</code></pre> <pre><code>[[(6.561360419843481, 70.76067563916963), (6.561360419843481, 51.1607)],\n [(35.76136041984348, 70.76067563916963), (35.76136041984348, 51.1607)],\n [(52.76136041984348, 70.76067563916963), (52.76136041984348, 51.1607)],\n [(97.76136041984348, 70.76067563916963), (97.76136041984348, 51.1607)],\n [(160.7613604198435, 70.76067563916963), (160.7613604198435, 51.1607)]]\n</code></pre> <pre><code>simple_joint_layer = joint_lines_modified_layer &lt;&lt; plain_width/2\nsimple_joint_layer\n</code></pre> <p></p> <pre><code>hole,dummy = frm.calc_hole(modified_joint_vertices,plain_width/2)\nfr.my_line_width=0\nholes = hole.to_laminate(NUM_LAYERS)\nholes&lt;&lt;=.5 # add a little extra material to ensure we removed enough.\nholes\n</code></pre> <p></p> <pre><code>&lt;Figure size 640x480 with 0 Axes&gt;\n</code></pre> <pre><code>rigid_layer = (body_layer - simple_joint_layer)\nrigid_layer\n</code></pre> <p></p> <pre><code>adhesive_layer = rigid_layer &amp; body_layer\nadhesive_layer\n</code></pre> <p></p> <pre><code>ideal_final_device = Laminate(rigid_layer,adhesive_layer, body_layer,\nadhesive_layer,rigid_layer)\nideal_final_device\n</code></pre> <p></p> <pre><code>ideal_final_device[0]\n</code></pre> <p></p> <pre><code>ideal_final_device[2]\n</code></pre> <p></p> <pre><code>bridges = frd.read_lines('grass_bar.dxf', layer='bridge')\nbridges\nbridges_layer = Layer(*[sg.LineString(item) for item in bridges])\nbridges_layer &lt;&lt;= bridge_thickness\nbridges_layer\n</code></pre> <p></p> <pre><code>bridges_lam = Laminate(bridges_layer,bridges_layer,Layer(),bridges_layer,bridges_layer)\nbridges_lam\n</code></pre> <p></p> <pre><code>supported_actual_device = ideal_final_device | bridges_lam\nsupported_actual_device\n</code></pre> <p></p> <pre><code>diff = supported_actual_device - ideal_final_device\nremoval = frm.cleanup(diff, .1)\nremoval\n</code></pre> <p></p> <pre><code>removal = frm.keepout_laser(removal)\nremoval\n</code></pre> <p></p> <pre><code>actual_final_device = ideal_final_device- holes - removal\nactual_final_device\n</code></pre> <p></p> <pre><code>keepout = frm.keepout_laser(actual_final_device)\nkeepout\n</code></pre> <p></p> <pre><code>layer_id = frm.build_layer_numbers(NUM_LAYERS,\ntext_size=jig_dia)\nlayer_id = layer_id.simplify(.2)\nlayer_id[0]\n</code></pre> <p></p> <pre><code>(x1,y1),(x2,y2) = actual_final_device.bounding_box_coords()\nw1,h1 = actual_final_device.get_dimensions()\nw2 = round(w1/jig_spacing)*jig_spacing+jig_spacing+support_width\nh2 = round(h1/jig_spacing)*jig_spacing+jig_spacing+support_width\nx1 -= (w2-w1)/2\ny1 -= (h2-h1)/2\nx2 += (w2-w1)/2\ny2 += (h2-h1)/2\npoints = []\npoints.append(sg.Point(x1,y1))\npoints.append(sg.Point(x2,y1))\npoints.append(sg.Point(x1,y2))\npoints.append(sg.Point(x2,y2))\nalignment_holes_layer = Layer(*points)\nalignment_holes_layer&lt;&lt;=(jig_dia/2)\nalignment_holes=alignment_holes_layer.to_laminate(NUM_LAYERS)\nalignment_holes\n</code></pre> <p></p> <pre><code>sheet_layer = (alignment_holes_layer&lt;&lt;bounding_box_padding).bounding_box()\nsheet=sheet_layer.to_laminate(NUM_LAYERS)\nsheet\n</code></pre> <p></p> <pre><code>removable_scrap = frm.calculate_removable_scrap(\nactual_final_device,sheet,support_width,is_adhesive)\nweb = removable_scrap-alignment_holes-layer_id.translate(x1+jig_dia,y1-jig_dia/2)\nweb\n</code></pre> <p></p> <pre><code>(web|actual_final_device)\n</code></pre> <p></p> <pre><code>second_pass_scrap = sheet-keepout\nsecond_pass_scrap\n</code></pre> <p></p> <pre><code>first_pass_scrap = sheet - second_pass_scrap - actual_final_device\nfirst_pass_scrap = frm.cleanup(first_pass_scrap,.00001)\nfirst_pass_scrap\n</code></pre> <p></p> <pre><code>support = frm.support(actual_final_device,\nfrm.keepout_laser,support_width,support_width/2)\nsupport\n</code></pre> <p></p> <pre><code>support | bridges_lam\n</code></pre> <p></p> <pre><code>supported_design = web|actual_final_device|support| bridges_lam\nsupported_design\n</code></pre> <p></p> <pre><code>cut_material = (keepout&lt;&lt;kerf)-keepout\ncut_material\n</code></pre> <p></p> <pre><code>remaining_material = supported_design-cut_material\nremaining_material\n</code></pre> <p></p> <pre><code>remaining_parts = frm.find_connected(remaining_material,is_adhesive)\nfor item in remaining_parts:\n    item.plot(new=True)\n</code></pre> <p></p> <p></p> <pre><code>test_part=actual_final_device&gt;&gt;1\nfor result in remaining_parts:\n    if not (result&amp;test_part).is_null():\n        break\nresult\n</code></pre> <p></p> <pre><code>check = (result^actual_final_device)\ncheck&gt;&gt;=1e-1\nassert(check.is_null())\n</code></pre> <pre><code>w,h = supported_design.get_dimensions()\np0,p1 = supported_design.bounding_box_coords()\nrigid_layer = supported_design[0] | (supported_design[-1].translate(w+5,0))\nrigid_layer\n</code></pre> <p></p> <pre><code>l4 = supported_design[3].scale(-1,1)\np2,p3 = l4.bounding_box_coords()\nl4 = l4.translate(p0[0]-p2[0]+w+5,p0[1]-p2[1])\nadhesive_layer = supported_design[1] | l4\nadhesive_layer\n</code></pre> <p></p> <pre><code>first_pass = Laminate(rigid_layer,adhesive_layer,supported_design[2])\nfirst_pass.export_dxf('first_pass')\n</code></pre> <pre><code>final_cut = sheet - keepout\nfinal_cut = final_cut[0]\nfinal_cut.export_dxf('final_cut')\nfinal_cut\n</code></pre> <p></p> <pre><code>from foldable_robotics.pdf import Page\nimport foldable_robotics.pdf as frp\n</code></pre> <pre><code># === 2-row grid with mirrored pairs + final_cut in top-right ===\n# Configure which laminate layers to use\nTOP_IDX = 4        # &lt;- pick the \"different\" layer number for the NEW TOP row\nBOTTOM_IDX = 3     # &lt;- your current layer number for the BOTTOM row\n\nS = frp.ppi / 25.4     # mm -&gt; PDF points\nPAD = 30               # page margins (pt)\nGAP_X, GAP_Y = 60, 80  # spacing between cells (pt)\nCELL_PAD = 12          # inner padding in each cell (pt)\n\ndef as_layer(obj):\n    # Accept a Layer or Laminate; return a Layer (first layer if Laminate) \n    return obj if hasattr(obj, \"get_paths\") else obj.layers[0]\n\ndef normalize(layer):\n    # Scale to points and move bottom-left to (0,0)\n    L = layer.scale(S, S)\n    (x0, y0), _ = L.bounding_box_coords()\n    return L.translate(-x0, -y0)\n\ndef mirror_h(layer):\n    # Mirror horizontally about the layer's own center\n    (a, b) = layer.bounding_box_coords()\n    cx = (a[0] + b[0]) / 2\n    return layer.translate(-cx, 0).scale(-1, 1).translate(cx, 0)\n\ndef size(layer):\n    (a, b) = layer.bounding_box_coords()\n    return (b[0] - a[0], b[1] - a[1])\n\ndef scale_to_fit(layer, w, h, pad=CELL_PAD):\n    lw, lh = size(layer)\n    if lw == 0 or lh == 0: \n        return layer\n    k = min((w - pad)/lw, (h - pad)/lh, 1.0)\n    return layer.scale(k, k)\n\ndef draw(page, obj):\n    # Draw a Layer or Laminate\n    layers = getattr(obj, \"layers\", [obj])\n    for lyr in layers:\n        for path in lyr.get_paths():\n            page.draw_poly(path)\n\n# --- build the six cells (2 rows \u00d7 3 cols) ---\n# top row: [ left_pair(original @ TOP_IDX), mirrored(TOP_IDX), final_cut ]\n# bottom row: [ left_pair(original @ BOTTOM_IDX), mirrored(BOTTOM_IDX), (empty) ]\n\ntop_left  = normalize(as_layer(supported_design[TOP_IDX]))\ntop_right = mirror_h(top_left)\n\nbot_left  = normalize(as_layer(supported_design[BOTTOM_IDX]))\nbot_right = mirror_h(bot_left)\n\nfinal_layer = normalize(as_layer(final_cut))   # final_cut already a Layer in your notebook\n\n# Estimate a reasonable cell size from the largest item\nmax_w = max(size(L)[0] for L in [top_left, top_right, bot_left, bot_right, final_layer])\nmax_h = max(size(L)[1] for L in [top_left, top_right, bot_left, bot_right, final_layer])\nCELL_W = max_w + 80\nCELL_H = max_h + 80\n\n# Page size (2 rows \u00d7 3 cols)\npage_w = PAD + 3*CELL_W + 2*GAP_X + PAD\npage_h = PAD + 2*CELL_H + GAP_Y + PAD\n\np = Page('grass_plus_final.pdf', height=page_h)\n\ndef place(layer, row, col):\n    # fit to cell and center within that cell\n    Lf = scale_to_fit(layer, CELL_W, CELL_H)\n    (a, b) = Lf.bounding_box_coords()\n    lw, lh = size(Lf)\n    x0 = PAD + col*(CELL_W + GAP_X)\n    y0 = page_h - PAD - (row+1)*CELL_H - row*GAP_Y  # rows from top\n    dx = x0 + (CELL_W - lw)/2 - a[0]\n    dy = y0 + (CELL_H - lh)/2 - a[1]\n    draw(p, Lf.translate(dx, dy))\n\n# Top row (row 0)\nplace(top_left,  0, 0)\nplace(top_right, 0, 1)\nplace(final_layer, 0, 2)\n\n# Bottom row (row 1)\nplace(bot_left,  1, 0)\nplace(bot_right, 1, 1)\n# leave (row 1, col 2) empty, or duplicate final_layer there if you like:\n# place(final_layer, 1, 2)\n\np.close()\nprint(\"\u2705 Exported: grass_two_rows_plus_final.pdf\")\n</code></pre> <pre><code>\u2705 Exported: grass_two_rows_plus_final.pdf\n</code></pre> <pre><code># === 2-row grid with mirrored pairs + final_cut in top-right ===\n# Configure which laminate layers to use\nTOP_IDX = 4        # &lt;- pick the \"different\" layer number for the NEW TOP row\nBOTTOM_IDX = 3     # &lt;- your current layer number for the BOTTOM row\n\nS = frp.ppi / 25.4     # mm -&gt; PDF points\nPAD = 30               # page margins (pt)\nGAP_X, GAP_Y = 60, 80  # spacing between cells (pt)\nCELL_PAD = 12          # inner padding in each cell (pt)\n\ndef as_layer(obj):\n    # Accept a Layer or Laminate; return a Layer (first layer if Laminate)\n    return obj if hasattr(obj, \"get_paths\") else obj.layers[0]\n\ndef normalize(layer):\n    # Scale to points and move bottom-left to (0,0)\n    L = layer.scale(S, S)\n    (x0, y0), _ = L.bounding_box_coords()\n    return L.translate(-x0, -y0)\n\ndef mirror_h(layer):\n    # Mirror horizontally about the layer's own center\n    (a, b) = layer.bounding_box_coords()\n    cx = (a[0] + b[0]) / 2\n    return layer.translate(-cx, 0).scale(-1, 1).translate(cx, 0)\n\ndef size(layer):\n    (a, b) = layer.bounding_box_coords()\n    return (b[0] - a[0], b[1] - a[1])\n\ndef scale_to_fit(layer, w, h, pad=CELL_PAD):\n    lw, lh = size(layer)\n    if lw == 0 or lh == 0:\n        return layer\n    k = min((w - pad)/lw, (h - pad)/lh, 1.0)\n    return layer.scale(k, k)\n\ndef draw(page, obj):\n    # Draw a Layer or Laminate\n    layers = getattr(obj, \"layers\", [obj])\n    for lyr in layers:\n        for path in lyr.get_paths():\n            page.draw_poly(path)\n\n# --- build the six cells for ONE LEG (2 rows \u00d7 3 cols) ---\n# top row: [ left_pair(original @ TOP_IDX), mirrored(TOP_IDX), final_cut ]\n# bottom row: [ left_pair(original @ BOTTOM_IDX), mirrored(BOTTOM_IDX), (empty) ]\n\ntop_left  = normalize(as_layer(supported_design[TOP_IDX]))\ntop_right = mirror_h(top_left)\n\nbot_left  = normalize(as_layer(supported_design[BOTTOM_IDX]))\nbot_right = mirror_h(bot_left)\n\nfinal_layer = normalize(as_layer(final_cut))   # final_cut already a Layer in your notebook\n\n# Estimate a reasonable cell size from the largest item\nmax_w = max(size(L)[0] for L in [top_left, top_right, bot_left, bot_right, final_layer])\nmax_h = max(size(L)[1] for L in [top_left, top_right, bot_left, bot_right, final_layer])\nCELL_W = max_w + 80\nCELL_H = max_h + 80\n\n# We now want TWO of these 2-row layouts stacked = 4 rows total\nNUM_ROWS_PER_LEG = 2\nNUM_LEGS = 2\nTOTAL_ROWS = NUM_ROWS_PER_LEG * NUM_LEGS  # 4 rows\n\n# Page size (4 rows \u00d7 3 cols = two legs on one page)\npage_w = PAD + 3*CELL_W + 2*GAP_X + PAD\npage_h = PAD + TOTAL_ROWS*CELL_H + (TOTAL_ROWS - 1)*GAP_Y + PAD\n\np = Page('grass_two_legs_plus_final.pdf', height=page_h)\n\ndef place(layer, row, col):\n    # fit to cell and center within that cell\n    Lf = scale_to_fit(layer, CELL_W, CELL_H)\n    (a, b) = Lf.bounding_box_coords()\n    lw, lh = size(Lf)\n    x0 = PAD + col*(CELL_W + GAP_X)\n    # rows counted from top\n    y0 = page_h - PAD - (row + 1)*CELL_H - row*GAP_Y\n    dx = x0 + (CELL_W - lw)/2 - a[0]\n    dy = y0 + (CELL_H - lh)/2 - a[1]\n    draw(p, Lf.translate(dx, dy))\n\n# Helper to place one leg\u2019s 2\u00d73 grid starting at a given row index\ndef place_leg(base_row):\n    # Top row for this leg\n    place(top_left,   base_row + 0, 0)\n    place(top_right,  base_row + 0, 1)\n    place(final_layer, base_row + 0, 2)\n\n    # Bottom row for this leg\n    place(bot_left,   base_row + 1, 0)\n    place(bot_right,  base_row + 1, 1)\n    # leave (base_row+1, col 2) empty, or duplicate final_layer if you like:\n    # place(final_layer, base_row + 1, 2)\n\n# Leg 1 (rows 0\u20131)\nplace_leg(0)\n\n# Leg 2 (rows 2\u20133), exact same layout duplicated lower on the page\nplace_leg(2)\n\np.close()\nprint(\"\u2705 Exported: grass_two_legs_plus_final.pdf\")\n</code></pre> <pre><code>\u2705 Exported: grass_two_legs_plus_final.pdf\n</code></pre> <pre><code>\n</code></pre>"},{"location":"static/node_modules/mathjax/","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#mathjax","title":"MathJax","text":""},{"location":"static/node_modules/mathjax/#beautiful-math-in-all-browsers","title":"Beautiful math in all browsers","text":"<p>MathJax is an open-source JavaScript display engine for LaTeX, MathML, and AsciiMath notation that works in all modern browsers.  It was designed with the goal of consolidating the recent advances in web technologies into a single, definitive, math-on-the-web platform supporting the major browsers and operating systems.  It requires no setup on the part of the user (no plugins to download or software to install), so the page author can write web documents that include mathematics and be confident that users will be able to view it naturally and easily.  Simply include MathJax and some mathematics in a web page, and MathJax does the rest.</p> <p>Some of the main features of MathJax include:</p> <ul> <li> <p>High-quality display of LaTeX, MathML, and AsciiMath notation in HTML pages</p> </li> <li> <p>Supported in most browsers with no plug-ins, extra fonts, or special   setup for the reader</p> </li> <li> <p>Easy for authors, flexible for publishers, extensible for developers</p> </li> <li> <p>Supports math accessibility, cut-and-paste interoperability, and other   advanced functionality</p> </li> <li> <p>Powerful API for integration with other web applications</p> </li> </ul> <p>See http://www.mathjax.org/ for additional details about MathJax, and https://docs.mathjax.org for the MathJax documentation.</p>"},{"location":"static/node_modules/mathjax/#mathjax-components","title":"MathJax Components","text":"<p>MathJax version 3 uses files called components that contain the various MathJax modules that you can include in your web pages or access on a server through NodeJS.  Some components combine all the pieces you need to run MathJax with one or more input formats and a particular output format, while other components are pieces that can be loaded on demand when needed, or by a configuration that specifies the pieces you want to combine in a custom way.  For usage instructions, see the MathJax documentation.</p> <p>Components provide a convenient packaging of MathJax's modules, but it is possible for you to form your own custom components, or to use MathJax's modules directly in a node application on a server.  There are web examples showing how to use MathJax in web pages and how to build your own components, and node examples illustrating how to use components in node applications or call MathJax modules directly.</p>"},{"location":"static/node_modules/mathjax/#whats-in-this-repository","title":"What's in this Repository","text":"<p>This repository contains only the component files for MathJax, not the source code for MathJax (which are available in a separate MathJax source repository).  These component files are the ones served by the CDNs that offer MathJax to the web.  In version 2, the files used on the web were also the source files for MathJax, but in version 3, the source files are no longer on the CDN, as they are not what are run in the browser.</p> <p>The components are stored in the <code>es5</code> directory, and are in ES5 format for the widest possible compatibility.  In the future, we may make an <code>es6</code> directory containing ES6 versions of the components.</p>"},{"location":"static/node_modules/mathjax/#installation-and-use","title":"Installation and Use","text":""},{"location":"static/node_modules/mathjax/#using-mathjax-components-from-a-cdn-on-the-web","title":"Using MathJax components from a CDN on the web","text":"<p>If you are loading MathJax from a CDN into a web page, there is no need to install anything.  Simply use a <code>script</code> tag that loads MathJax from the CDN.  E.g.,</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>See the MathJax documentation, the MathJax Web Demos, and the MathJax Component Repository for more information.</p>"},{"location":"static/node_modules/mathjax/#hosting-your-own-copy-of-the-mathjax-components","title":"Hosting your own copy of the MathJax Components","text":"<p>If you want to host MathJax from your own server, you can do so by installing the <code>mathjax</code> package using <code>npm</code> and moving the <code>es5</code> directory to an appropriate location on your server:</p> <pre><code>npm install mathjax@3\nmv node_modules/mathjax/es5 &lt;path-to-server-location&gt;/mathjax\n</code></pre> <p>Note that we are still making updates to version 2, so include <code>@3</code> when you install, since the latest chronological version may not be version 3.</p> <p>Alternatively, you can get the files via GitHub:</p> <pre><code>git clone https://github.com/mathjax/MathJax.git mj-tmp\nmv mj-tmp/es5 &lt;path-to-server-location&gt;/mathjax\nrm -rf mj-tmp\n</code></pre> <p>Then (in either case) you can use a script tag like the following:</p> <pre><code>&lt;script id=\"MathJax-script\" async src=\"&lt;url-to-your-site&gt;/mathjax/tex-chtml.js\"&gt;&lt;/script&gt;\n</code></pre> <p>where <code>&lt;url-to-your-site&gt;</code> is replaced by the URL to the location where you moved the MathJax files above.</p> <p>See the documentation for details.</p>"},{"location":"static/node_modules/mathjax/#using-mathjax-components-in-a-node-application","title":"Using MathJax components in a node application","text":"<p>To use MathJax components in a node application, install the <code>mathjax</code> package:</p> <pre><code>npm install mathjax@3\n</code></pre> <p>(we are still making updates to version 2, so you should include <code>@3</code> since the latest chronological version may not be version 3).</p> <p>Then require <code>mathjax</code> within your application:</p> <pre><code>require('mathjax').init({ ... }).then((MathJax) =&gt; { ... });\n</code></pre> <p>where the first <code>{ ... }</code> is a MathJax configuration, and the second <code>{ ... }</code> is the code to run after MathJax has been loaded.  E.g.</p> <pre><code>require('mathjax').init({\n  loader: {load: ['input/tex', 'output/svg']}\n}).then((MathJax) =&gt; {\n  const svg = MathJax.tex2svg('\\\\frac{1}{x^2-1}', {display: true});\n  console.log(MathJax.startup.adaptor.outerHTML(svg));\n}).catch((err) =&gt; console.log(err.message));\n</code></pre> <p>Note: this technique is for node-based application only, not for browser applications.  This method sets up an alternative DOM implementation, which you don't need in the browser, and tells MathJax to use node's <code>require()</code> command to load external modules.  This setup will not work properly in the browser, even if you webpack it or bundle it in other ways.</p> <p>See the documentation and the MathJax Node Repository for more details.</p>"},{"location":"static/node_modules/mathjax/#reducing-the-size-of-the-components-directory","title":"Reducing the Size of the Components Directory","text":"<p>Since the <code>es5</code> directory contains all the component files, so if you are only planning one use one configuration, you can reduce the size of the MathJax directory by removing unused components. For example, if you are using the <code>tex-chtml.js</code> component, then you can remove the <code>tex-mml-chtml.js</code>, <code>tex-svg.js</code>, <code>tex-mml-svg.js</code>, <code>tex-chtml-full.js</code>, and <code>tex-svg-full.js</code> configurations, which will save considerable space.  Indeed, you should be able to remove everything other than <code>tex-chtml.js</code>, and the <code>input/tex/extensions</code>, <code>output/chtml/fonts/woff-v2</code>, <code>adaptors</code>, <code>a11y</code>, and <code>sre</code> directories.  If you are using the results only on the web, you can remove <code>adaptors</code> as well.</p> <p>If you are not using A11Y support (e.g., speech generation, or semantic enrichment), then you can remove <code>a11y</code> and <code>sre</code> as well (though in this case you may need to disable the assistive tools in the MathJax contextual menu in order to avoid MathJax trying to load them when they aren't there).</p> <p>If you are using SVG rather than CommonHTML output (e.g., <code>tex-svg.js</code> rather than <code>tex-chtml.js</code>), you can remove the <code>output/chtml/fonts/woff-v2</code> directory.  If you are using MathML input rather than TeX (e.g., <code>mml-chtml.js</code> rather than <code>tex-chtml.js</code>), then you can remove <code>input/tex/extensions</code> as well.</p>"},{"location":"static/node_modules/mathjax/#the-component-files-and-pull-requests","title":"The Component Files and Pull Requests","text":"<p>The <code>es5</code> directory is generated automatically from the contents of the MathJax source repository.  You can rebuild the components using the command</p> <pre><code>npm run make-es5 --silent\n</code></pre> <p>Note that since the contents of this repository are generated automatically, you should not submit pull requests that modify the contents of the <code>es5</code> directory.  If you wish to submit a modification to MathJax, you should make a pull request in the MathJax source repository.</p>"},{"location":"static/node_modules/mathjax/#mathjax-community","title":"MathJax Community","text":"<p>The main MathJax website is http://www.mathjax.org, and it includes announcements and other important information.  A MathJax user forum for asking questions and getting assistance is hosted at Google, and the MathJax bug tracker is hosted at GitHub.</p> <p>Before reporting a bug, please check that it has not already been reported.  Also, please use the bug tracker (rather than the help forum) for reporting bugs, and use the user's forum (rather than the bug tracker) for questions about how to use MathJax.</p>"},{"location":"static/node_modules/mathjax/#mathjax-resources","title":"MathJax Resources","text":"<ul> <li>MathJax Documentation</li> <li>MathJax Components</li> <li>MathJax Source Code</li> <li>MathJax Web Examples</li> <li>MathJax Node Examples</li> <li>MathJax Bug Tracker</li> <li>MathJax Users' Group</li> </ul>"},{"location":"subfolder/","title":"This is the index to a subfolder","text":"<p>Things to discuss</p>"},{"location":"subfolder/another-subfile/","title":"This is a secondary sub page","text":"<p>Things to discuss</p>"}]}